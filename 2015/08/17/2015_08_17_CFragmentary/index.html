
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>C 语言：零碎知识总结 | Liu2er的技术博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Liu2er">
    

    <meta name="keywords" content="C">
    <meta name="description" content="回调函数顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数。
// 定义回调函数1
void PrintfText()
{
    pri">
<meta property="og:type" content="article">
<meta property="og:title" content="C 语言：零碎知识总结">
<meta property="og:url" content="http://liu2er.com/2015/08/17/2015_08_17_CFragmentary/index.html">
<meta property="og:site_name" content="Liu2er的技术博客">
<meta property="og:description" content="回调函数顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数。
// 定义回调函数1
void PrintfText()
{
    pri">
<meta property="og:image" content="http://dl.iteye.com/upload/picture/pic/115454/2d89dcdc-0a17-3ac8-afbe-c2782f498cbe.gif">
<meta property="og:updated_time" content="2016-09-22T11:54:36.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C 语言：零碎知识总结">
<meta name="twitter:description" content="回调函数顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数。
// 定义回调函数1
void PrintfText()
{
    pri">
<meta name="twitter:image" content="http://dl.iteye.com/upload/picture/pic/115454/2d89dcdc-0a17-3ac8-afbe-c2782f498cbe.gif">

    
    <link rel="alternative" href="/atom.xml" title="Liu2er的技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Liu2er的技术博客">Liu2er的技术博客</a></h1>
				<h2 class="blog-motto">世界那么大，我早晚要去看</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:liu2er.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_CFragmentary/" title="C 语言：零碎知识总结" itemprop="url">C 语言：零碎知识总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T02:48:28.000Z" itemprop="datePublished"> 发表于 2015-08-17</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#回调函数"><span class="toc-number">1.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环、迭代、递归、遍历"><span class="toc-number">2.</span> <span class="toc-text">循环、迭代、递归、遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆、栈的区别"><span class="toc-number">3.</span> <span class="toc-text">堆、栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-说明符"><span class="toc-number">4.</span> <span class="toc-text">const 说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常变量"><span class="toc-number">4.0.1.</span> <span class="toc-text">常变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常数组"><span class="toc-number">4.0.2.</span> <span class="toc-text">常数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指向常变量的指针变量"><span class="toc-number">4.0.3.</span> <span class="toc-text">指向常变量的指针变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指向常量的指针"><span class="toc-number">4.0.4.</span> <span class="toc-text">指向常量的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常对象"><span class="toc-number">4.0.5.</span> <span class="toc-text">常对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常引用"><span class="toc-number">4.0.6.</span> <span class="toc-text">常引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-函数形参"><span class="toc-number">4.0.7.</span> <span class="toc-text">const 函数形参</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C语言的bool类型"><span class="toc-number">5.</span> <span class="toc-text">C语言的bool类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL、URI-和-URN-的区别"><span class="toc-number">6.</span> <span class="toc-text">URL、URI 和 URN 的区别</span></a></li></ol>
		
		</div>
		
		<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数。</p>
<pre><code>// 定义回调函数1
void PrintfText()
{
    printf(&quot;Hello World!\n&quot;);
}

// 定义回调函数2
void PrintfInt()
{
    printf(&quot;10\n&quot;);
}

// 定义实现回调函数的&quot;调用函数&quot;
void CallPrintf(void (*callfuct)(void))
{
    callfuct();
}

// 在main函数中实现函数回调
int main(int argc,char* argv[])
{
    CallPrintf(PrintfText);
    CallPrintf(PrintfInt);
    return 0;
}
</code></pre><a id="more"></a>
<h2 id="循环、迭代、递归、遍历"><a href="#循环、迭代、递归、遍历" class="headerlink" title="循环、迭代、递归、遍历"></a>循环、迭代、递归、遍历</h2><p>表示重复的词有很多，比如循环（loop）、递归（recursion）、迭代（iterate）、遍历（traversal）等。其中迭代在数学和编程中的含义是不同的。</p>
<ul>
<li><strong> 循环：</strong>凡是重复执行一段代码都可以成为循环。<ul>
<li>大部分的迭代、递归、遍历都是循环。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong> 迭代（数学）：</strong>在循环的基础上，每一次循环都比上一次更为接近结果。<ul>
<li>与普通循环不同的是，迭代的循环代码中参与运算的变量同时也是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</li>
<li>迭代是使用计数器结束循环。</li>
<li>迭代的一个经典例子是累加求和。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong> 迭代（编程）：</strong>按顺序访问线性结构中的每一项。<ul>
<li>迭代的一个经典例子是累加求和。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong> 递归：</strong>重复调用函数自身实现循环。<ul>
<li>递归循环中，遇到满足终止条件后逐层返回来结束。</li>
<li>递归的一个经典例子是折半查找。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong> 遍历：</strong>按顺序访问一个非线性结构中的每一项，比如树和图；而迭代一般用于线性结构，如数组、队列；</li>
</ul>
<p>参考文章：</p>
<p><a href="http://www.nowamagic.net/librarys/veda/detail/2324" target="_blank" rel="external">漫谈递归：循环与迭代是一回事吗？</a></p>
<h2 id="堆、栈的区别"><a href="#堆、栈的区别" class="headerlink" title="堆、栈的区别"></a>堆、栈的区别</h2><ol>
<li><strong>管理方式</strong><ul>
<li><strong>栈，</strong>是由编译器自动分配和释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈；</li>
<li><strong>堆，</strong>是由程序员手动分配和释放，容易产生内存泄露问题。OC 对象就存在堆里。它与数据结构中的堆是两回事，分配方式类似于数据结构中的链表；      </li>
</ul>
</li>
<li><strong>申请大小</strong><ul>
<li><strong>栈，</strong>是向低地址扩展的数据结构，是一块连续的内存的区域。顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将导致栈溢出。因此，能从栈获得的空间较小。</li>
<li><strong>堆，</strong>是向高地址扩展的数据结构，是不连续的内存区域。由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li>
</ul>
</li>
<li><strong>碎片问题</strong><ul>
<li><strong>栈，</strong>是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。</li>
<li><strong>堆，</strong>频繁的创建和释放对象势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。</li>
</ul>
</li>
<li><strong>分配方式</strong><ul>
<li><strong>栈，</strong>栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 alloca 函数进行分配。但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</li>
<li><strong>堆，</strong>堆都是动态分配的，没有静态分配的堆。</li>
</ul>
</li>
<li><strong>分配效率</strong><ul>
<li><strong>栈，</strong>是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。</li>
<li><strong>堆，</strong>堆则是由函数库提供的，它的机制是很复杂的。</li>
</ul>
</li>
<li><strong>缓存方式</strong><ul>
<li><strong>栈，</strong>使用的是一级缓存，调用完毕后会被立即释放；</li>
<li><strong>堆，</strong>是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦释放就回收）。所以调用这些对象的速度要相对慢一些；</li>
</ul>
</li>
</ol>
<p><strong>OC 对象所占内存总是分配在堆空间，而绝不会分配在栈上。</strong>（本结论来自《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》）</p>
<p><img src="http://dl.iteye.com/upload/picture/pic/115454/2d89dcdc-0a17-3ac8-afbe-c2782f498cbe.gif" alt="图片"></p>
<p>参考网址：</p>
<p><a href="http://blog.csdn.net/sqc3375177/article/details/16805481" target="_blank" rel="external">IOS中堆和栈的区别</a></p>
<h2 id="const-说明符"><a href="#const-说明符" class="headerlink" title="const 说明符"></a>const 说明符</h2><p>如果变量声明中带有关键字 const，则一旦初始化完成后就不能通过赋值、增量或减量运算来修改变量的值。</p>
<h4 id="常变量"><a href="#常变量" class="headerlink" title="常变量"></a>常变量</h4><pre><code>const 类型说明符 变量名 
</code></pre><p>eg：<code>const int a</code>;</p>
<p>如果一个变量已被声明为常变量，则只能用指向常变量的指针变量指向它，而不能用一般的指针变量去指向它。</p>
<p>而指向常变量的指针变量（eg：<code>const int *ptr</code>）除了可以指向常变量外，还可以指向未被声明为 const 的普通变量。此时不能通过此指针变量改变该变量的值。</p>
<h4 id="常数组"><a href="#常数组" class="headerlink" title="常数组"></a>常数组</h4><pre><code>const 类型说明符 数组[大小]
</code></pre><p>eg：<code>int const a[5] = {1， 2， 3， 4， 5};</code> 本数组一旦创建并初始化完成后就不能再被修改，例如执行<code>a[2] = 10;</code>这样的操作会报编译错误；</p>
<h4 id="指向常变量的指针变量"><a href="#指向常变量的指针变量" class="headerlink" title="指向常变量的指针变量"></a>指向常变量的指针变量</h4><pre><code>const 类型说明符 * 指针变量名
</code></pre><p>等价于</p>
<pre><code>类型说明符 const * 变量名
</code></pre><p>eg：<code>const int * a;  等价于 int const * a;</code></p>
<p>a 是一个指针常量，a 本身的值可以被改变，即可以改变 a 里存放的地址，但是 a 指针所指向的内容不可改变。即 a 是一个指向 int 型常量的指针。</p>
<p>举例：</p>
<pre><code>int array[5] = {1, 2, 3, 4, 5};
const int *ptr = array;

*ptr     = 10;    // 不允许
ptr[2]   = 20;    // 不允许

array[2] = 30;    // 允许
ptr++;            // 允许
</code></pre><p>ptr 已经被声明为指针常量，就不可以再用 ptr 来修改它所指向的数组内容。而 array 并没有被声明为常量，所以仍然可以使用 array 来修改其数组内容。</p>
<h4 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h4><pre><code>类型说明符 * const 指针变量名
</code></pre><p>eg：<code>int * const a;</code></p>
<p>a 是一个常量指针，a 本身的值是不可以改变的，即 a 必须始终指向同一个地址，但它所指向的地址里存放的内容是可以改变的。</p>
<ul>
<li><p>由指针常量和指针常量的对比，我们可以更进一步确认 const 关键字所表示的常量的理解方式确实是从右边往左进行。</p>
</li>
<li><p>另外<code>const int * const a;</code>则表明 a 必须总是指向同一个地址，而且这个地址里存放的内容也是不可变的。</p>
</li>
<li><p>总之，一个位于 <em> 左边任意位置的 const 使得<strong>数据</strong>成为常量，而一个位于 </em> 右边的 const 使得<strong>指针自身</strong>为常量。</p>
</li>
</ul>
<h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h4><pre><code>类名 * const 对象名
</code></pre><p>eg：<code>NSString *const string = @&quot;MyString&quot;;</code></p>
<p>MyString 是一个常量，而这个常量是指针类型的，指向 NSString 对象。</p>
<h4 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h4><pre><code>const 类型说明符 引用名
</code></pre><h4 id="const-函数形参"><a href="#const-函数形参" class="headerlink" title="const 函数形参"></a>const 函数形参</h4><p>如果指针只是用来让函数访问值，就把它声明为 const 受限指针。如果指针被用来改变调用函数中的数据，则不使用关键字 const。例如 ANSI C 中的 strcat() 声明如下：</p>
<pre><code>char *strcat(char *, const char *);
</code></pre><p>STRing CATenate，字符串连接函数，把第二个字符数组中的字符串连接到第一个字符串的后面。所以第一个字符串的地址不变，但是第二个字符串的地址变了；    </p>
<p>又例如：</p>
<pre><code>void display (const int array[], int limit);

等价于：

void display (const int *array, int limit);
</code></pre><p>在将数组名作为实际参数传递给函数时，实际上传递的是数组的首地址，所以上面两种写法等价；加上 const 关键字表示传递给函数的指针 array 指向的数据是不可变的，函数不能用这个指针来修改数据。</p>
<h2 id="C语言的bool类型"><a href="#C语言的bool类型" class="headerlink" title="C语言的bool类型"></a>C语言的bool类型</h2><p>在 C++ 里有专门的 bool 类型，用来表示真或假。但是在 C 语言标准（C89）没有定义布尔类型，所以 C 语言判断真假时以 0 为假，非 0 为真。所以我们通常使用逻辑变量的做法：</p>
<pre><code>//定义一个int类型变量，当变量值为0时表示false，值为1时表示true
int flag;
flag = 0;
//......
flag = 1;

if( flag )
{
    //......
}
</code></pre><p>但这种做法不直观，而且没有明确 flag 一定是布尔值。所以为了使程序更清晰，最常见的写法是利用宏定义：</p>
<pre><code>//宏定义布尔类型
#define BOOL int
#define TRUE 1
#define FALSE 0

//定义一个布尔变量
BOOL flag = FALSE;
</code></pre><p>参考网址：</p>
<p><a href="http://www.cnblogs.com/pharen/archive/2012/02/06/2340257.html" target="_blank" rel="external">C语言的布尔类型</a></p>
<p><a href="http://niehan.blog.techweb.com.cn/archives/228.html" target="_blank" rel="external">浅谈C语言中的布尔（bool）类型</a></p>
<h2 id="URL、URI-和-URN-的区别"><a href="#URL、URI-和-URN-的区别" class="headerlink" title="URL、URI 和 URN 的区别"></a>URL、URI 和 URN 的区别</h2><ul>
<li><strong>URI：</strong>统一资源标志符（Universal Resource Identifier），Web上可用的每种资源—— HTML 文档、图像、视频片段、程序等都可以通过 URI 进行定位。例如，一个服务器上的一个文件夹/网页的绝对地址就是 URI。</li>
<li><strong>URL：</strong>统一资源定位符（Universal Resource Location），URL 是 Internet 上用来描述信息资源的字符串，主要用在各种 WWW 客户程序和服务器程序上。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。</li>
<li><strong>URN：</strong>统一资源名称（Uniform Resource Name）。</li>
<li><strong>URI 和 URL 的区别：</strong>URI 定义资源，而 URL 不单定义这个资源，还定义了如何找到这个资源。 </li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://liu2er.com/2015/08/17/2015_08_17_CFragmentary/" data-title="C 语言：零碎知识总结 | Liu2er的技术博客" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/08/22/2015_08_22_OCFragmentary/" title="OC：零碎知识总结">
  <strong>上一篇：</strong><br/>
  <span>
  OC：零碎知识总结</span>
</a>
</div>


<div class="next">
<a href="/2015/08/16/2015_08_16_NSStringIsEqual/"  title="isEqual 和 == 的比较">
 <strong>下一篇：</strong><br/> 
 <span>isEqual 和 == 的比较
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/08/17/2015_08_17_CFragmentary/" data-title="C 语言：零碎知识总结" data-url="http://liu2er.com/2015/08/17/2015_08_17_CFragmentary/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#回调函数"><span class="toc-number">1.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环、迭代、递归、遍历"><span class="toc-number">2.</span> <span class="toc-text">循环、迭代、递归、遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆、栈的区别"><span class="toc-number">3.</span> <span class="toc-text">堆、栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-说明符"><span class="toc-number">4.</span> <span class="toc-text">const 说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常变量"><span class="toc-number">4.0.1.</span> <span class="toc-text">常变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常数组"><span class="toc-number">4.0.2.</span> <span class="toc-text">常数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指向常变量的指针变量"><span class="toc-number">4.0.3.</span> <span class="toc-text">指向常变量的指针变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指向常量的指针"><span class="toc-number">4.0.4.</span> <span class="toc-text">指向常量的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常对象"><span class="toc-number">4.0.5.</span> <span class="toc-text">常对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常引用"><span class="toc-number">4.0.6.</span> <span class="toc-text">常引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-函数形参"><span class="toc-number">4.0.7.</span> <span class="toc-text">const 函数形参</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C语言的bool类型"><span class="toc-number">5.</span> <span class="toc-text">C语言的bool类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL、URI-和-URN-的区别"><span class="toc-number">6.</span> <span class="toc-text">URL、URI 和 URN 的区别</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Blog/" title="Blog">Blog<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/C/" title="C">C<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Git/" title="Git">Git<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C/" title="Objective-C">Objective-C<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>10</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/RAC/" title="RAC">RAC<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Octopress/" title="Octopress">Octopress<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Delegate/" title="Delegate">Delegate<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Git/" title="Git">Git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NSString/" title="NSString">NSString<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/isEqual/" title="isEqual">isEqual<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Fragmentary/" title="Fragmentary">Fragmentary<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Push/" title="Push">Push<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UINavigationController/" title="UINavigationController">UINavigationController<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UIButton/" title="UIButton">UIButton<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NSUserDefaults/" title="NSUserDefaults">NSUserDefaults<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Blosks/" title="Blosks">Blosks<sup>1</sup></a></li>
			
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Liu2er">Liu2er</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"liu2er"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 









<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
