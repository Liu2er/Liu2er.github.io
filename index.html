
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Liu2er的技术博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Liu2er">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Liu2er的技术博客">
<meta property="og:url" content="http://liu2er.com/index.html">
<meta property="og:site_name" content="Liu2er的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liu2er的技术博客">

    
    <link rel="alternative" href="/atom.xml" title="Liu2er的技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Liu2er的技术博客">Liu2er的技术博客</a></h1>
				<h2 class="blog-motto">世界那么大，我早晚要去看</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:liu2er.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/18/2016_10_18_KengUIImage/" title="UIImage 和 UIImageView" itemprop="url">UIImage 和 UIImageView</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-10-18T07:14:13.000Z" itemprop="datePublished"> 发表于 2016-10-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="图片的5种创建方式"><a href="#图片的5种创建方式" class="headerlink" title="图片的5种创建方式"></a>图片的5种创建方式</h2><ul>
<li>使用类方法 <code>imageNamed:</code> 创建</li>
<li>使用类方法 <code>imageWithContentsOfFile:</code> 创建</li>
<li>使用类方法 <code>imageWithData:</code> 创建</li>
<li>使用类方法 <code>imageWithCGImage:</code> 创建</li>
<li>使用类方法 <code>imageWithCIImage:</code> 创建</li>
</ul>
<p>参考 <a href="http://www.superqq.com/blog/2015/07/28/four-create-uiimage-method/" target="_blank" rel="external">五种创建UIImage的类方法</a>。</p>
<h2 id="图片的添加与大小"><a href="#图片的添加与大小" class="headerlink" title="图片的添加与大小"></a>图片的添加与大小</h2><ul>
<li><code>imageView.image =</code>：完全填充，图片被拉伸。<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((<span class="keyword">self</span>.view.bounds.size.width - <span class="number">300</span>) * <span class="number">0.5</span>, <span class="number">20</span>, <span class="number">300</span>, <span class="number">300</span>)];</div><div class="line">   imageView.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">   <span class="comment">// [imageView setImage:[UIImage imageNamed:@"TestImage"]];</span></div><div class="line">   imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"TestImage"</span>];    </div><div class="line">   [<span class="keyword">self</span>.view addSubview:imageView];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用 <code>imageNamed:</code> 初始化的时候，系统会先去检查缓存中是否存在该名字的图片，如果不存在，则系统先缓存该图片，再返回该图片对象；如果存在，直接返回要加载的图片对象。这种机制适合于那种频繁用到界面贴图类的加载，但如果我们需要短时间内频繁的加载一些一次性的图像的话，最好不要使用这种方法。（当收到内存警告的时候，系统可能会将UIImage内部的存储图像的内存释放，下一次需要绘制的时候会重新去加载。）</p>
<ul>
<li><p><code>imageView.backgroundColor =</code>：图片原来尺寸，但是 imageView 里充满了该 image。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((<span class="keyword">self</span>.view.bounds.size.width - <span class="number">300</span>) * <span class="number">0.5</span>, <span class="number">340</span>, <span class="number">300</span>, <span class="number">300</span>)];</div><div class="line">   imageView.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">   imageView.backgroundColor = [<span class="built_in">UIColor</span> colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"TestImage2"</span>]];</div><div class="line">   [<span class="keyword">self</span>.view addSubview:imageView];</div></pre></td></tr></table></figure>
</li>
<li><p><code>[imageView sizeToFit]</code>：重新把 UIImageView 的 size 改变为图片的大小。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((<span class="keyword">self</span>.view.bounds.size.width - <span class="number">300</span>) * <span class="number">0.5</span>, <span class="number">340</span>, <span class="number">300</span>, <span class="number">200</span>)];</div><div class="line">imageView.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"TestImage2"</span>];</div><div class="line">[imageView sizeToFit];</div><div class="line">[<span class="keyword">self</span>.view addSubview:imageView];</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="给-UIView-设置背景图片的三种方式"><a href="#给-UIView-设置背景图片的三种方式" class="headerlink" title="给 UIView 设置背景图片的三种方式"></a>给 UIView 设置背景图片的三种方式</h2><ul>
<li><p>方法1：<code>[self.view sendSubviewToBack:imageView]</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((<span class="keyword">self</span>.view.bounds.size.width - <span class="number">300</span>) * <span class="number">0.5</span>, <span class="number">340</span>, <span class="number">300</span>, <span class="number">100</span>)];</div><div class="line">[imageView setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"TestImage2"</span>]];</div><div class="line">[<span class="keyword">self</span>.view addSubview:imageView];</div><div class="line">[<span class="keyword">self</span>.view sendSubviewToBack:imageView];</div></pre></td></tr></table></figure>
</li>
<li><p>方法2：<code>view.backgroundColor = [UIColor colorWithPatternImage:image]</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((<span class="keyword">self</span>.view.bounds.size.width - <span class="number">300</span>) * <span class="number">0.5</span>, <span class="number">340</span>, <span class="number">300</span>, <span class="number">300</span>)];</div><div class="line">view.backgroundColor = [<span class="built_in">UIColor</span> colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"TestImage2"</span>]];</div><div class="line">[<span class="keyword">self</span>.view addSubview:view];</div></pre></td></tr></table></figure>
</li>
<li><p>方法3：<code>把 UIImageView 放到最底层</code><br>iOS 视图都是一个图层，最先放置的视图就会在最底层，因此，最先给一个视图添加一个 UIImageView 后，然后再在上面一一添加其他控件，效果也跟背景图片差不多。</p>
</li>
</ul>
<h2 id="关于图片的尺寸问题"><a href="#关于图片的尺寸问题" class="headerlink" title="关于图片的尺寸问题"></a>关于图片的尺寸问题</h2><p>在 Retina 屏幕上，如果图片 <code>TestImage.png</code> 的尺寸为 <code>128 x 128</code>，如果对同一张图片用不同的命名，会有如下结果</p>
<table>
<thead>
<tr>
<th>图片名称</th>
<th>NSLog图片的size</th>
<th>image.scale</th>
</tr>
</thead>
<tbody>
<tr>
<td>TestImage.png</td>
<td>128 x 128</td>
<td>1.0</td>
</tr>
<tr>
<td>TestImage@2x.png</td>
<td>64 x 64</td>
<td>2.0</td>
</tr>
<tr>
<td>TestImage@3x.png</td>
<td>42.666666666666664 x 42.666666666666664</td>
<td>3.0</td>
</tr>
<tr>
<td>TestImage@4x.png</td>
<td>128 x 128</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<p>在界面布局中逻辑坐标系中的单位是 <code>point</code>，而实际的绘制都是在设备坐标系单位是 <code>pixel</code> 进行的，系统会自动帮我们完成从 point 到 pixel 之间的转化。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/UIImage/">UIImage</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/10/18/2016_10_18_KengUIImage/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/10/18/2016_10_18_KengUIImage/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/18/2016_10_18_UIImage/" title="UIImage 和 UIImageView" itemprop="url">UIImage 和 UIImageView</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-10-18T07:14:13.000Z" itemprop="datePublished"> 发表于 2016-10-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="图片的5种创建方式"><a href="#图片的5种创建方式" class="headerlink" title="图片的5种创建方式"></a>图片的5种创建方式</h2><ul>
<li>使用类方法 <code>imageNamed:</code> 创建</li>
<li>使用类方法 <code>imageWithContentsOfFile:</code> 创建</li>
<li>使用类方法 <code>imageWithData:</code> 创建</li>
<li>使用类方法 <code>imageWithCGImage:</code> 创建</li>
<li>使用类方法 <code>imageWithCIImage:</code> 创建</li>
</ul>
<p>参考 <a href="http://www.superqq.com/blog/2015/07/28/four-create-uiimage-method/" target="_blank" rel="external">五种创建UIImage的类方法</a>。</p>
<h2 id="图片的添加与大小"><a href="#图片的添加与大小" class="headerlink" title="图片的添加与大小"></a>图片的添加与大小</h2><ul>
<li><code>imageView.image =</code>：完全填充，图片被拉伸。<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((<span class="keyword">self</span>.view.bounds.size.width - <span class="number">300</span>) * <span class="number">0.5</span>, <span class="number">20</span>, <span class="number">300</span>, <span class="number">300</span>)];</div><div class="line">   imageView.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">   <span class="comment">// [imageView setImage:[UIImage imageNamed:@"TestImage"]];</span></div><div class="line">   imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"TestImage"</span>];    </div><div class="line">   [<span class="keyword">self</span>.view addSubview:imageView];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用 <code>imageNamed:</code> 初始化的时候，系统会先去检查缓存中是否存在该名字的图片，如果不存在，则系统先缓存该图片，再返回该图片对象；如果存在，直接返回要加载的图片对象。这种机制适合于那种频繁用到界面贴图类的加载，但如果我们需要短时间内频繁的加载一些一次性的图像的话，最好不要使用这种方法。（当收到内存警告的时候，系统可能会将UIImage内部的存储图像的内存释放，下一次需要绘制的时候会重新去加载。）</p>
<ul>
<li><p><code>imageView.backgroundColor =</code>：图片原来尺寸，但是 imageView 里充满了该 image。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((<span class="keyword">self</span>.view.bounds.size.width - <span class="number">300</span>) * <span class="number">0.5</span>, <span class="number">340</span>, <span class="number">300</span>, <span class="number">300</span>)];</div><div class="line">   imageView.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">   imageView.backgroundColor = [<span class="built_in">UIColor</span> colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"TestImage2"</span>]];</div><div class="line">   [<span class="keyword">self</span>.view addSubview:imageView];</div></pre></td></tr></table></figure>
</li>
<li><p><code>[imageView sizeToFit]</code>：重新把 UIImageView 的 size 改变为图片的大小。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((<span class="keyword">self</span>.view.bounds.size.width - <span class="number">300</span>) * <span class="number">0.5</span>, <span class="number">340</span>, <span class="number">300</span>, <span class="number">200</span>)];</div><div class="line">imageView.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"TestImage2"</span>];</div><div class="line">[imageView sizeToFit];</div><div class="line">[<span class="keyword">self</span>.view addSubview:imageView];</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="给-UIView-设置背景图片的三种方式"><a href="#给-UIView-设置背景图片的三种方式" class="headerlink" title="给 UIView 设置背景图片的三种方式"></a>给 UIView 设置背景图片的三种方式</h2><ul>
<li><p>方法1：<code>[self.view sendSubviewToBack:imageView]</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((<span class="keyword">self</span>.view.bounds.size.width - <span class="number">300</span>) * <span class="number">0.5</span>, <span class="number">340</span>, <span class="number">300</span>, <span class="number">100</span>)];</div><div class="line">[imageView setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"TestImage2"</span>]];</div><div class="line">[<span class="keyword">self</span>.view addSubview:imageView];</div><div class="line">[<span class="keyword">self</span>.view sendSubviewToBack:imageView];</div></pre></td></tr></table></figure>
</li>
<li><p>方法2：<code>view.backgroundColor = [UIColor colorWithPatternImage:image]</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>((<span class="keyword">self</span>.view.bounds.size.width - <span class="number">300</span>) * <span class="number">0.5</span>, <span class="number">340</span>, <span class="number">300</span>, <span class="number">300</span>)];</div><div class="line">view.backgroundColor = [<span class="built_in">UIColor</span> colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"TestImage2"</span>]];</div><div class="line">[<span class="keyword">self</span>.view addSubview:view];</div></pre></td></tr></table></figure>
</li>
<li><p>方法3：<code>把 UIImageView 放到最底层</code><br>iOS 视图都是一个图层，最先放置的视图就会在最底层，因此，最先给一个视图添加一个 UIImageView 后，然后再在上面一一添加其他控件，效果也跟背景图片差不多。</p>
</li>
</ul>
<h2 id="关于图片的尺寸问题"><a href="#关于图片的尺寸问题" class="headerlink" title="关于图片的尺寸问题"></a>关于图片的尺寸问题</h2><p>在 Retina 屏幕上，如果图片 <code>TestImage.png</code> 的尺寸为 <code>300 x 300</code>，如果对同一张图片用不同的命名，会有如下结果</p>
<table>
<thead>
<tr>
<th>图片名称</th>
<th>NSLog图片的size</th>
<th>image.scale</th>
</tr>
</thead>
<tbody>
<tr>
<td>TestImage.png</td>
<td>300 x 300</td>
<td>1.0</td>
</tr>
<tr>
<td>TestImage@2x.png</td>
<td>150 x 150</td>
<td>2.0</td>
</tr>
<tr>
<td>TestImage@3x.png</td>
<td>100 x 100</td>
<td>3.0</td>
</tr>
<tr>
<td>TestImage@4x.png</td>
<td>300 x 300</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<p>在界面布局中逻辑坐标系中的单位是 <code>point</code>，而实际的绘制都是在设备坐标系单位是 <code>pixel</code> 进行的，系统会自动帮我们完成从 point 到 pixel 之间的转化。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/UIImage/">UIImage</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/10/18/2016_10_18_UIImage/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/10/18/2016_10_18_UIImage/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/11/2016_10_11_Keng/" title="开发过程中踩过的坑" itemprop="url">开发过程中踩过的坑</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-10-11T07:29:01.000Z" itemprop="datePublished"> 发表于 2016-10-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="回主线程刷新-tableView"><a href="#回主线程刷新-tableView" class="headerlink" title="回主线程刷新 tableView"></a>回主线程刷新 tableView</h2><p>请求数据回来后一定要重新刷新self.tableView，而且是在主线程中刷新，否则会出现没有数据，只有点击了屏幕才会有数据出现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)requestData &#123;</div><div class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://huidu.dper.com/testflight/listOwners?type=0"</span>];</div><div class="line">    <span class="built_in">NSURLSessionTask</span> *task = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            <span class="comment">// 处理 error</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 处理请求回来的数据</span></div><div class="line">        </div><div class="line">        <span class="comment">// 返回主线程刷新 tableView</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">        &#125;);</div><div class="line">    &#125;];</div><div class="line">    [task resume];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Keng/">Keng</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/10/11/2016_10_11_Keng/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/10/11/2016_10_11_Keng/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/08/2016_10_08_iOSAnimation/" title="iOS 动画" itemprop="url">iOS 动画</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-10-08T02:06:39.000Z" itemprop="datePublished"> 发表于 2016-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h2><p>相比较于 Quartz 2D 绘图，使用 Core Animation 创建动画不仅简单，而且性能更好，原因如下：</p>
<ul>
<li>Core Animation 动画在<code>单独线程</code>中完成，不会阻塞主线程；</li>
<li>Core Animation 动画只会重绘界面上变化的部分（<code>局部刷新</code>）。</li>
</ul>
<p>Core Animation 的核心是 CALayer。Core Animation 主要涉及的 API 有：CAAnimation、CATransition、CAPropertyAnimation、CABasicAnimation、CAKeyframeAnimation、CAAnimationGroup。</p>
<h3 id="CABasicAnimation-举例"><a href="#CABasicAnimation-举例" class="headerlink" title="CABasicAnimation 举例"></a>CABasicAnimation 举例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  位移动画演示</div><div class="line"> */</div><div class="line">-(<span class="keyword">void</span>)positionAnimation&#123;</div><div class="line">    <span class="comment">//使用CABasicAnimation创建基础动画</span></div><div class="line">    <span class="built_in">CABasicAnimation</span> *anima = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</div><div class="line">    anima.fromValue = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>)];</div><div class="line">    anima.toValue = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>)];</div><div class="line">    anima.duration = <span class="number">1.0</span>f;</div><div class="line">    <span class="comment">//如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。</span></div><div class="line">    <span class="comment">//但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</span></div><div class="line">    <span class="comment">//anima.fillMode = kCAFillModeForwards;</span></div><div class="line">    <span class="comment">//anima.removedOnCompletion = NO;</span></div><div class="line">    anima.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn];</div><div class="line">    [_demoView.layer addAnimation:anima forKey:<span class="string">@"positionAnimation"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CAAnimationGroup-举例"><a href="#CAAnimationGroup-举例" class="headerlink" title="CAAnimationGroup 举例"></a>CAAnimationGroup 举例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建组动画对象</span></div><div class="line">   <span class="built_in">CAAnimationGroup</span> *group = [<span class="built_in">CAAnimationGroup</span> animation];</div><div class="line">   </div><div class="line">   <span class="comment">//CABasic动画</span></div><div class="line">   <span class="built_in">CABasicAnimation</span> *animation1 = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.scale.y"</span>];</div><div class="line">   animation1.fromValue = @<span class="number">1.5</span>;</div><div class="line">   animation1.toValue = @<span class="number">0.5</span>;</div><div class="line">   </div><div class="line">   <span class="comment">//关键帧动画</span></div><div class="line">   <span class="built_in">CAKeyframeAnimation</span> *animation2 = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</div><div class="line">   animation2.values = @[[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>)],</div><div class="line">                         [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">150</span>)],</div><div class="line">                         [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">200</span>)],</div><div class="line">                         [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">250</span>)]];</div><div class="line">   </div><div class="line">   <span class="comment">//group添加动画数组，group中动画对象并发执行</span></div><div class="line">   [group setAnimations:@[animation1, animation2]];</div><div class="line">   [group setDuration:<span class="number">4.0</span>f];</div><div class="line">   </div><div class="line">   [_demoView.layer addAnimation:group forKey:<span class="string">@"group"</span>];</div></pre></td></tr></table></figure>
<h2 id="UIView-动画"><a href="#UIView-动画" class="headerlink" title="UIView 动画"></a>UIView 动画</h2><h3 id="使用-UIView-Animation-代码块调用"><a href="#使用-UIView-Animation-代码块调用" class="headerlink" title="使用 UIView Animation 代码块调用"></a>使用 UIView Animation 代码块调用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_demoView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>);</div><div class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span>f animations:^&#123;</div><div class="line">    _demoView.frame = <span class="built_in">CGRectMake</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>);</div><div class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">    _demoView.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">50</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="使用-UIView-begin-commit-模式"><a href="#使用-UIView-begin-commit-模式" class="headerlink" title="使用 UIView [begin, commit] 模式"></a>使用 UIView [begin, commit] 模式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_demoView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>);</div><div class="line">[<span class="built_in">UIView</span> beginAnimations:<span class="literal">nil</span> context:<span class="literal">nil</span>];</div><div class="line">[<span class="built_in">UIView</span> setAnimationDuration:<span class="number">1.0</span>f];</div><div class="line">_demoView.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">50</span>);</div><div class="line">[<span class="built_in">UIView</span> commitAnimations];</div></pre></td></tr></table></figure>
<p>举例2</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)changeFrame &#123;</div><div class="line">    [<span class="built_in">UIView</span> beginAnimations:<span class="string">@"FrameAni"</span> context:<span class="literal">nil</span>];</div><div class="line">    [<span class="built_in">UIView</span> setAnimationDuration:<span class="number">1.0</span>];</div><div class="line">    [<span class="built_in">UIView</span> setAnimationDelegate:<span class="keyword">self</span>];</div><div class="line">    [<span class="built_in">UIView</span> setAnimationWillStartSelector:<span class="keyword">@selector</span>(startAni:)];</div><div class="line">    [<span class="built_in">UIView</span> setAnimationDidStopSelector:<span class="keyword">@selector</span>(stopAni:)];</div><div class="line">    [<span class="built_in">UIView</span> setAnimationRepeatCount:<span class="number">1</span>];</div><div class="line">    [<span class="built_in">UIView</span> setAnimationCurve:<span class="built_in">UIViewAnimationCurveEaseInOut</span>];</div><div class="line">    <span class="keyword">self</span>.cartCenter.frame = <span class="keyword">self</span>.centerShow.frame;</div><div class="line">    [<span class="built_in">UIView</span> commitAnimations];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)startAni:(<span class="built_in">NSString</span> *)aniID &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ start"</span>,aniID);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stopAni:(<span class="built_in">NSString</span> *)aniID &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ stop"</span>,aniID);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CGAffineTransformMake-仿射变换"><a href="#CGAffineTransformMake-仿射变换" class="headerlink" title="CGAffineTransformMake 仿射变换"></a>CGAffineTransformMake 仿射变换</h2><p>UIView 有 CGAffineTransform 类型的属性 transform，它是定义在二维空间上完成 view 的平移、旋转、缩放等效果。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> animations:^&#123;</div><div class="line">       _demoView.transform = <span class="built_in">CGAffineTransformMakeTranslation</span>(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<h2 id="UIView-中的坐标转换"><a href="#UIView-中的坐标转换" class="headerlink" title="UIView 中的坐标转换"></a>UIView 中的坐标转换</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将像素point由point所在视图转换到目标视图view中，返回在目标视图view中的像素值</span></div><div class="line">- (<span class="built_in">CGPoint</span>)convertPoint:(<span class="built_in">CGPoint</span>)point toView:(<span class="built_in">UIView</span> *)view;</div><div class="line"><span class="comment">// 将像素point从view中转换到当前视图中，返回在当前视图中的像素值</span></div><div class="line">- (<span class="built_in">CGPoint</span>)convertPoint:(<span class="built_in">CGPoint</span>)point fromView:(<span class="built_in">UIView</span> *)view;</div><div class="line"></div><div class="line"><span class="comment">// 将rect由rect所在视图转换到目标视图view中，返回在目标视图view中的rect</span></div><div class="line">- (<span class="built_in">CGRect</span>)convertRect:(<span class="built_in">CGRect</span>)rect toView:(<span class="built_in">UIView</span> *)view;</div><div class="line"><span class="comment">// 将rect从view中转换到当前视图中，返回在当前视图中的rect</span></div><div class="line">- (<span class="built_in">CGRect</span>)convertRect:(<span class="built_in">CGRect</span>)rect fromView:(<span class="built_in">UIView</span> *)view;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Animation/">Animation</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/10/08/2016_10_08_iOSAnimation/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/10/08/2016_10_08_iOSAnimation/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/28/2016_09_28_NSLog/" title="NSLog 使用总结" itemprop="url">NSLog 使用总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-09-28T10:04:29.000Z" itemprop="datePublished"> 发表于 2016-09-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="输出-枚举"><a href="#输出-枚举" class="headerlink" title="输出 枚举"></a>输出 枚举</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSStringFromCGPoint</span>();</div><div class="line"><span class="built_in">NSStringFromCGSize</span>();</div><div class="line"><span class="built_in">NSStringFromCGRect</span>();</div><div class="line"><span class="built_in">NSStringFromCGAffineTransform</span>();</div><div class="line"><span class="built_in">NSStringFromUIEdgeInsets</span>();</div></pre></td></tr></table></figure>
<h2 id="输出-方法名"><a href="#输出-方法名" class="headerlink" title="输出 方法名"></a>输出 方法名</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</div></pre></td></tr></table></figure>
<h2 id="输出-结构体"><a href="#输出-结构体" class="headerlink" title="输出 结构体"></a>输出 结构体</h2><h2 id="输出的-Debug-区分"><a href="#输出的-Debug-区分" class="headerlink" title="输出的 Debug 区分"></a>输出的 Debug 区分</h2><h2 id="CG-与-NSString-的互相转换"><a href="#CG-与-NSString-的互相转换" class="headerlink" title="CG 与 NSString 的互相转换"></a>CG 与 NSString 的互相转换</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *<span class="built_in">NSStringFromCGPoint</span>(<span class="built_in">CGPoint</span> point);</div><div class="line"><span class="built_in">NSString</span> *<span class="built_in">NSStringFromCGVector</span>(<span class="built_in">CGVector</span> vector);</div><div class="line"><span class="built_in">NSString</span> *<span class="built_in">NSStringFromCGSize</span>(<span class="built_in">CGSize</span> size);</div><div class="line"><span class="built_in">NSString</span> *<span class="built_in">NSStringFromCGRect</span>(<span class="built_in">CGRect</span> rect);</div><div class="line"><span class="built_in">NSString</span> *<span class="built_in">NSStringFromCGAffineTransform</span>(<span class="built_in">CGAffineTransform</span> transform);</div><div class="line"><span class="built_in">NSString</span> *<span class="built_in">NSStringFromUIEdgeInsets</span>(<span class="built_in">UIEdgeInsets</span> insets);</div><div class="line"><span class="built_in">NSString</span> *<span class="built_in">NSStringFromUIOffset</span>(<span class="built_in">UIOffset</span> offset);</div><div class="line"></div><div class="line"><span class="built_in">CGPoint</span> <span class="built_in">CGPointFromString</span>(<span class="built_in">NSString</span> *string);</div><div class="line"><span class="built_in">CGVector</span> <span class="built_in">CGVectorFromString</span>(<span class="built_in">NSString</span> *string);</div><div class="line"><span class="built_in">CGSize</span> <span class="built_in">CGSizeFromString</span>(<span class="built_in">NSString</span> *string);</div><div class="line"><span class="built_in">CGRect</span> <span class="built_in">CGRectFromString</span>(<span class="built_in">NSString</span> *string);</div><div class="line"><span class="built_in">CGAffineTransform</span> <span class="built_in">CGAffineTransformFromString</span>(<span class="built_in">NSString</span> *string);</div><div class="line"><span class="built_in">UIEdgeInsets</span> <span class="built_in">UIEdgeInsetsFromString</span>(<span class="built_in">NSString</span> *string);</div><div class="line"><span class="built_in">UIOffset</span> <span class="built_in">UIOffsetFromString</span>(<span class="built_in">NSString</span> *string);</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/NSLog/">NSLog</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/09/28/2016_09_28_NSLog/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/09/28/2016_09_28_NSLog/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/26/2016_09_26_Notifications/" title="Local and Remote Notifications" itemprop="url">Local and Remote Notifications</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-09-26T02:40:06.000Z" itemprop="datePublished"> 发表于 2016-09-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文翻译自<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1" target="_blank" rel="external">苹的果 Notification 官方文档</a></p>
<h2 id="About-Local-and-Remote-Notifications"><a href="#About-Local-and-Remote-Notifications" class="headerlink" title="About Local and Remote Notifications"></a>About Local and Remote Notifications</h2><h3 id="Notifications-的分类"><a href="#Notifications-的分类" class="headerlink" title="Notifications 的分类"></a>Notifications 的分类</h3><ul>
<li>User Notifications<ul>
<li>Local Notifications</li>
</ul>
<ul>
<li>Remote Notifications（Push Notifications）</li>
</ul>
</li>
<li>Broadcast Notificaitons (NSNotificationCenter 类)</li>
<li>Key-value Observing Notifications</li>
</ul>
<h3 id="User-Notifications"><a href="#User-Notifications" class="headerlink" title="User Notifications"></a>User Notifications</h3><p>User notifications 可以使没有运行在前台的 APP 通知其用户有消息到达。比如，这个消息可以是一个信息、一个即将到来的日历事件或者是远程服务器上的新数据。当系统呈现该通知消息时，不管是本地通知还是远程通知，其展现形式是一样的。它们可以展示一个通知消息或者在应用图标上标记数字小红点。当通知消息或应用图标有数字小红点时，也可以发出声音提示。</p>
<blockquote>
<p>User notifications enable an app that isn’t running in the foreground to let its users know it has information for them. The information could be a message, an impending calendar event, or new data on a remote server, for example. When presented by the operating system, user notifications, whether local or remote in origin, look and sound the same. They can display an alert message or they can badge the app icon. They can also play a sound when the alert or badge number is shown.</p>
</blockquote>
<p>接收到 user notification 后，用户可以通过点击它来打开相应的 app 查看消息细节。当 app 处于非活跃状态时，用户也可以选择忽略该信息。</p>
<blockquote>
<p>Upon receiving a user notification, the user can tap it to launch the associated app and see the details. They can also choose to ignore the notification, in which case the app is not activated.</p>
</blockquote>
<h3 id="At-a-Glance"><a href="#At-a-Glance" class="headerlink" title="At a Glance"></a>At a Glance</h3><p>Local notifications 和 remote notifications 看起来一样，但实际上它们用于不同的情况，而且其配置和管理方式也不同。</p>
<blockquote>
<p>Local and remote notifications appear the same to a user, but they serve different use cases and you configure and manage them differently.</p>
</blockquote>
<h4 id="Local-notifications-和-Remote-notifications-的区别"><a href="#Local-notifications-和-Remote-notifications-的区别" class="headerlink" title="Local notifications 和 Remote notifications 的区别"></a>Local notifications 和 Remote notifications 的区别</h4><ul>
<li>A local notification is scheduled and sent by the app itself, without necessary involvement of the Internet.</li>
<li>A remote notification, also called a push notification, arrives from outside the device. It originates on a remote server that you manage—the app’s notification provider—and is pushed to your app on a user’s device via the Apple Push Notification service (APNs).</li>
</ul>
<h4 id="Registering-Scheduling-and-Handling-User-Notifications"><a href="#Registering-Scheduling-and-Handling-User-Notifications" class="headerlink" title="Registering, Scheduling, and Handling User Notifications"></a>Registering, Scheduling, and Handling User Notifications</h4><p>系统要在接下来的某个时间发送一个 local notification，app 需要注册通知类型、创建本地通知对象（用 UNNotificationRequest 类或 NSUserNotification 类），设置一个发送时间、说明展示细节，然后发送。要接收 remote notifications，app 要注册通知类型，并将由系统获得的 app 的 deviceToken 传达给自己的后台服务器。</p>
<blockquote>
<p>For the system to deliver a local notification at a later time, an app registers notification types, creates a local notification object (using either the UNNotificationRequest or NSUserNotification class), assigns it a delivery date and time, specifies presentation details, and schedules it for delivery. To receive remote notifications, an app must register notification types, then pass to its provider an app-specific device token it gets from the operating system.</p>
</blockquote>
<p>当系统发送一个 local notification 或 remote notification 且相应的 app 没有运行在前台时，该通知可以通过以信息、图标数字小红点和声音的方式来展现。当用户点击了通知消息或者触发按钮（或者触发滑动条），app 将会启动，并调用一个方法来传递本地通知对象或远程通知 payload。如果当通知消息到达时 app 是运行在前台的，将会以代理的方式来接收该本地或远程通知消息。</p>
<blockquote>
<p>When the operating system delivers a local notification or remote notification and the target app is not running in the foreground, it can present the notification to the user through an alert, icon badge number, or sound. If there is a notification alert and the user taps or clicks an action button (or moves the action slider), the app launches and calls a method to pass in the local-notification object or remote-notification payload. If the app is running in the foreground when the notification is delivered, the app delegate receives a local or remote notification.</p>
</blockquote>
<p>在 iOS 8 及更新的系统中，user notifications 可以包含自定义的行为。而且，当用户到达特定的地理位置时，基于位置服务的通知也可以被送达。</p>
<blockquote>
<p>In iOS 8 and later, user notifications can include custom actions. Also, location-based local notifications can be sent whenever the user arrives at a particular geographic location.</p>
</blockquote>
<h4 id="Apple-Push-Notification-Service"><a href="#Apple-Push-Notification-Service" class="headerlink" title="Apple Push Notification Service"></a>Apple Push Notification Service</h4><p>苹果推送通知服务（APNs）向拥有注册了接收该通知的 app 的设备传送远程通知。设备上每个 app 需要与 APNs 建立 accredited and encrypted IP 连接，app 通过该长连接来接收通知消息。后台服务器通过一个持续的、安全的通道与 APNs 建立连接来监视其客户 app 的输入数据。当一个 app 的新数据达到时，后台服务器通过该通道向 APNs 准备并发送一个通知，这个通知再被传输到指定设备。</p>
<blockquote>
<p>Apple Push Notification service (APNs) propagates remote notifications to devices having apps registered to receive those notifications. Each app on a device establishes an accredited and encrypted IP connection with the service and receives notifications over this persistent connection. Providers connect with APNs through a persistent and secure channel while monitoring incoming data intended for their client apps. When new data for an app arrives, the provider prepares and sends a notification through the channel to APNs, which pushes the notification to the target device.</p>
</blockquote>
<p>APNs Provider API 是异步的，并于 2015 年 12 月开始使用 HTTP/2 网络协议来从你自己的后台服务器向 APNs 向发送远程通知请求。后台服务器创建每个外发通知，并用此通道发送给 APNs。</p>
<blockquote>
<p>The APNs Provider API is asynchronous and, starting in December 2015, uses the HTTP/2 network protocol to send remote notification requests from your provider server to APNs. The provider composes each outgoing notification and sends it over this channel to APNs.</p>
</blockquote>
<h4 id="Security-Credentials-for-Remote-Notifications"><a href="#Security-Credentials-for-Remote-Notifications" class="headerlink" title="Security Credentials for Remote Notifications"></a>Security Credentials for Remote Notifications</h4><p>为了给你的 app 开发和部署一个远程通知<code>后台服务器</code>，你必须从你的开发者帐号中获得有效的身份认证。<code>基于 HTTP/2 的 APNs provider API</code> 可以让你的开发和发布环境只用一个认证证书就可以。具体参考 <a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012582" target="_blank" rel="external">App Distribution Guide</a> 里的 <a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6" target="_blank" rel="external">Configuring Push Notifications</a>。</p>
<blockquote>
<p>To develop and deploy a remote notification provider server for your app, you must obtain valid credentials from your developer account. The HTTP/2-based APNs provider API lets you use a single certificate for the development and production environments, as described in Configuring Push Notifications in App Distribution Guide.</p>
</blockquote>
<p>现在你可以使用<code>基于 token 的认证</code>来向 与你的 Team ID 相关的所有 app 发送通知了。例如，你的单一认证证书允许你发送通知给你的主 app，这是通过 bundle ID 来识别的，也可以发送给你相关的、即使运行在后台的 <code>Apple Watch 应用</code>和 <code>VoIP 服务</code>。</p>
<blockquote>
<p>You can now use token-based authentication to send to notifications to all the apps associated with your Team ID. For example, your single certificate lets you send notifications to your primary app, as identified by its bundle ID, and also to associated Apple Watch complications and to VoIP services even when they are running in the background.</p>
</blockquote>
<h4 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h4><p><a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_blank" rel="external">App Programming Guide for iOS</a> 介绍了编写 iOS app 时的高级模式。</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_blank" rel="external">App Programming Guide for iOS</a> describes the high level patterns for writing iOS apps.</p>
</blockquote>
<p>对于 local notification 和 remote notification 客户端的实现，我们是假设你已经熟悉了 <code>iOS app</code> 的开发。对于后台服务器的实现，<code>TLS/SSL</code> 和 <code>sockets 流</code>的知识会很有帮助。</p>
<blockquote>
<p>For local notifications and the client-side implementation of remote notifications, familiarity with app development for iOS is assumed. For the provider side of the implementation, knowledge of TLS/SSL and streaming sockets is helpful.</p>
</blockquote>
<h2 id="Local-and-Remote-Notifications-in-Depth"><a href="#Local-and-Remote-Notifications-in-Depth" class="headerlink" title="Local and Remote Notifications in Depth"></a>Local and Remote Notifications in Depth</h2><h2 id="Registering-Scheduling-and-Handling-User-Notifications-1"><a href="#Registering-Scheduling-and-Handling-User-Notifications-1" class="headerlink" title="Registering, Scheduling, and Handling User Notifications"></a>Registering, Scheduling, and Handling User Notifications</h2><p>app 要想接收本地通知和远程通知，就必须进行合理的配置。这个配置过程对于 iOS 和 macOS 是有略微差别的，但是基本原则还是一样的。app 启动时，app 要进行注册并且与系统一起配置以接收通知。一旦注册完成，你就可以开始创建发送到你的 app 上的通知了。app 处理这些接收到的通知，并提供适当的回应。</p>
<blockquote>
<p>Apps must be configured appropriately before they can receive local or remote notifications. The configuration process differs slightly on iOS and macOS, but the basic principles are the same. At launch time, your app registers to receive notifications and works with the system to configure that notification support. Once registration is complete, you can start creating notifications for delivery to your app. Your app then handles these incoming notifications and provides an appropriate response.</p>
</blockquote>
<p>在 iOS 和 tvOS 中，注册被分为两个部分：注册所支持的用户交互和注册通知本身。注册所支持的用户交互类型是用来告诉系统当通知到达时逆向如何通知用户。本地通知和远程通知都需要做这一步。对于远程通知，你必须进行第二步的注册来获取指定 app 的 deviceToken，这个 deviceToken 用于 APNs 服务器传输通知。本地通知则没有这一步。在 macOS 系统中，只有当 app 支持远程通知时才需要注册。</p>
<blockquote>
<p>In iOS and tvOS, registration is divided into two parts: registering the supported user interactions and registering for the notifications themselves. Registering your app’s supported user interaction types tells the operating system how you want to notify the user when a notification arrives. This step is required for both local or remote notifications. For remote notifications, you must perform a second registration step to obtain the app-specific device token used by the APNs server to deliver notifications. (For local notifications, there is no second registration step.) In macOS, registration is necessary only for apps that support remote notifications.</p>
</blockquote>
<p>如果需要关于发送和接收远程（推送）通知的相关帮助，请参考 Note TN2265，<a href="https://developer.apple.com/library/content/technotes/tn2265/" target="_blank" rel="external">Troubleshooting Push Notifications</a></p>
<blockquote>
<p>For help with issues you encounter with sending or receiving remote (push) notifications, read Technical Note TN2265, <a href="https://developer.apple.com/library/content/technotes/tn2265/" target="_blank" rel="external">Troubleshooting Push Notifications</a></p>
</blockquote>
<h3 id="Registering-Your-iOS-App’s-Supported-User-Interaction-Types"><a href="#Registering-Your-iOS-App’s-Supported-User-Interaction-Types" class="headerlink" title="Registering Your iOS App’s Supported User Interaction Types"></a>Registering Your iOS App’s Supported User Interaction Types</h3><p>在 iOS 8 及更新的系统中，不管是使用本地通知还是使用远程通知的 app 都需要注册 app 所支持的交互类型。app 可以显示图标小角标、展示通知信息或播放声音。当你请求这些交互类型中的任何一个或多个时，系统都会检查用户为其 app 所允许的这些交互类型。如果用户禁止了某种交互类型，系统就会忽略掉该交互行为。例如，如果一个通知想展示一条通知消息并播放一段声音，但是用户禁止掉了该声音交互类型，系统就会只展示通知消息而不会播放声音。</p>
<blockquote>
<p>In iOS 8 and later, apps that use either local or remote notifications must register the types of user interactions the app supports. Apps can ask to badge icons, display alert messages, or play sounds. When you request any of these interaction types, the system checks the types of interactions the user has allowed for your app. If the user has disallowed a particular type of interaction, the system ignores attempts to interact with the user in that way. For example, if a notification wants to display an alert message and play a sound, and the user has disallowed sounds, the system displays the alert message but does not play the sound.</p>
</blockquote>
<p>为了注册你的 app 所支持的交互类型，调用 UIApplication 单例对象的 <code>registerUserNotificationSettings:</code> 方法，用 settings object 来说明你的 app 是否支持应用程序图标小角标、消息展示或播放声音。如果你没有申请任何一种交互类型，系统就会静默地推送通知。表 2-1 展示了一个 app 支持消息展示和声音播放的代码片段。第一行的 UIUserNotificationType 类型赋值是通知 API 所不可或缺的。</p>
<blockquote>
<p>To register your app’s supported interaction types, call the registerUserNotificationSettings: method of the shared UIApplication object. Use the settings object to specify whether your app badges its icon, displays alert messages, or plays sounds. If you do not request any interaction types, the system pushes all notifications to your app silently. Listing 2-1 shows a short code snippet for an app that supports displaying alert messages and playing sounds. (The cast to the UIUserNotificationType type, in the first line of the snippet, is required by the notifications API.)</p>
</blockquote>
<p>表 2-1 通知类型注册<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIUserNotificationType</span> types = (<span class="built_in">UIUserNotificationType</span>) (<span class="built_in">UIUserNotificationTypeBadge</span> | <span class="built_in">UIUserNotificationTypeSound</span> | <span class="built_in">UIUserNotificationTypeAlert</span>);</div><div class="line"></div><div class="line"><span class="built_in">UIUserNotificationSettings</span> *mySettings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:types categories:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:mySettings];</div></pre></td></tr></table></figure></p>
<p>除了注册 app 的交互类型，也可以注册一个或多个 Category，用于辨认通知的目的。</p>
<blockquote>
<p>In addition to registering your app’s interaction types, apps can register one or more categories. Categories are supported for both local and remote notifications, and you use them to identify the purpose of the notification. Your iOS app can use the category identifier to decide how to handle the notification. In watchOS, categories are also used to customize the notification interface displayed to the user.</p>
</blockquote>
<p>从 iOS 8 开始，</p>
<blockquote>
<p>Starting in iOS 8, you can optionally create actionable notifications by registering custom actions for a notification type. When an actionable notification arrives, the system creates a button for each registered action and adds those buttons to the notification interface. These action buttons give the user a quick way to perform tasks related to the notification. For example, a remote notification for a meeting invite might offer actions to accept or decline the meeting. When the user taps one of your action buttons, the system notifies your app, giving you an opportunity to perform the corresponding task. For information about how to configure actionable notifications, see Registering Your Actionable Notification Types.</p>
</blockquote>
<p>app 第一次调用 <code>registerUserNotificationSettings:</code> 方法时，iOS 会提示用户是否要允许这些具体的交互（即是否允许应用程序图标小角标、展示消息或播放声音）。app 在随后的启动过程中，调用此方法时不会再提示用户是否允许交互设置了。当调用完此方法后，iOS 异步地传递该结果到 <code>application:didRegisterUserNotificationSettings:</code> 代理方法。第一次注册通知的设置时，iOS 等用户相应后再调用此方法，但是在接下来的调用中，就会直接返回已经存在的设置结果。</p>
<p>注：<code>application:didRegisterUserNotificationSettings:</code> 方法可以返回用户在<strong>设置</strong>里关于该 app 的设置结果。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// APP 每次冷启动时都会调用本方法，输出真实的通知允许状态(即设置里的通知开关状态)</span></div><div class="line">-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didRegisterUserNotificationSettings:(<span class="built_in">UIUserNotificationSettings</span> *)notificationSettings &#123;</div><div class="line">    <span class="built_in">NSString</span> *messageString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, notificationSettings];</div><div class="line">    <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"通知"</span> message:messageString delegate:<span class="keyword">self</span> cancelButtonTitle:<span class="string">@"知道了"</span> otherButtonTitles:<span class="literal">nil</span>, <span class="literal">nil</span>];</div><div class="line">    [alertView show];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>The first time an app calls the <code>registerUserNotificationSettings:</code> method, iOS prompts the user to allow the specified interactions. On subsequent launches, calling this method does not prompt the user. After you call the method, iOS reports the results asynchronously to the <code>application:didRegisterUserNotificationSettings:</code> method of your app delegate. The first time you register your settings, iOS waits for the user’s response before calling this method, but on subsequent calls it returns the existing user settings.</p>
</blockquote>
<p>用户可以在<strong>设置</strong>里改变 app 通知的设置。</p>
<blockquote>
<p>The user can change the notification settings for your app at any time using the Settings app. Because settings can change, always call the <code>registerUserNotificationSettings:</code> at launch time and use the <code>application:didRegisterUserNotificationSettings:</code> method to get the response. If the user disallows specific notification types, avoid using those types when configuring local and remote notifications for your app.</p>
</blockquote>
<h3 id="Registering-for-Remote-Notifications"><a href="#Registering-for-Remote-Notifications" class="headerlink" title="Registering for Remote Notifications"></a>Registering for Remote Notifications</h3><p>app 要想接收远程通知，必须向 APNs 注册并获取相关的 deviceToken。iOS 8 以后的系统的注册包括以下步骤：</p>
<ul>
<li>注册通知的交互类型。</li>
<li>调用 <code>registerForRemoteNotifications</code> 方法注册远程通知。</li>
<li>用代理方法  <code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code> 拿到 deviceToken，用 <code>application:didFailToRegisterForRemoteNotificationsWithError:</code> 方法处理错误情况。</li>
<li>注册成功后，就可以向自己的产生通知内容的后台服务器发送 deviceToken 了。</li>
</ul>
<blockquote>
<p>An app that wants to receive remote notifications must register with Apple Push Notification service (APNs) to get an appropriate device token. In iOS 8 and later, registration involves the following steps:</p>
<ul>
<li>Register your app’s supported interaction types as described in Registering Your iOS App’s Supported User Interaction Types.</li>
<li>Call the <code>registerForRemoteNotifications</code> method to register your app for remote notifications. (In macOS, you use the registerForRemoteNotificationTypes: method to register your app’s interaction types and register for remote notifications in one step.)</li>
<li>Use your app delegate’s <code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code> method to receive the device token needed to deliver remote notifications. Use the <code>application:didFailToRegisterForRemoteNotificationsWithError:</code> method to process errors.</li>
<li>If registration was successful, send the device token to the server you use to generate remote notifications.</li>
</ul>
</blockquote>
<p>注：如果没有网络连接的话，<code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code> 和 <code>application:didFailToRegisterForRemoteNotificationsWithError:</code> 都不会被调用。</p>
<blockquote>
<p>If a cellular or Wi-Fi connection is not available, neither the <code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code> method nor the <code>application:didFailToRegisterForRemoteNotificationsWithError:</code> method is called. For Wi-Fi connections, this sometimes occurs when the device cannot connect with APNs over the configured port. If this happens, the user can move to another Wi-Fi network that isn’t blocking the required port or, on an iPhone or iPad, wait until the cellular data service becomes available. In either case, the device should be able to make the connection, and then one of the delegate methods is called.</p>
</blockquote>
<p>deviceToken 是可以变化的，所以 app 每次启动时都要进行注册，并把获取的 deviceToken 发给自己的服务器。当用户恢复备份的数据到一个新设备或电脑时，或重装系统时，deviceToken 都是会发生变化的。所以，当迁移数据到一个新设备或电脑时，用户要在远程通知到来之前至少启动一次 app。</p>
<blockquote>
<p>The device token is your key to sending push notifications to your app on a specific device. Device tokens can change, so your app needs to reregister every time it is launched and pass the received token back to your server. If you fail to update the device token, remote notifications might not make their way to the user’s device. Device tokens always change when the user restores backup data to a new device or computer or reinstalls the operating system. When migrating data to a new device or computer, the user must launch your app once before remote notifications can be delivered to that device.</p>
</blockquote>
<p>不要缓存 deviceToken，而是每次需要 deviceToken 时都直接从系统上获取。如果你的 app 之前注册过远程通知，再次调用  <code>registerForRemoteNotifications</code>  方法不会引起额外的开支，iOS 会向你的代理返回已存的 deviceToken。另外，当 deviceToken 发生变化时就会调用代理方法，而不是仅当注册通知或重复注册时。</p>
<blockquote>
<p>Never cache a device token; always get the token from the system whenever you need it. If your app previously registered for remote notifications, calling the <code>registerForRemoteNotifications</code> method again does not incur any additional overhead, and iOS returns the existing device token to your app delegate immediately. In addition, iOS calls your delegate method any time the device token changes, not just in response to your app registering or re-registering.</p>
</blockquote>
<p>表 2-2 展示了如何给 iOS app 注册远程通知。当注册完 app 所支持的通知交互类型后，就会调用<strong>单例的 app 对象</strong>的 <code>registerForRemoteNotifications</code> 方法。一接收到 deviceToken 代理方法就会调用自定义的代码将该 deviceToken 传给自己的后台服务器。</p>
<blockquote>
<p>Listing 2-2 shows how to register for remote notifications in an iOS app. After registering the app’s supported action types, the method calls the <code>registerForRemoteNotifications</code> method of the shared app object. Upon receiving the device token, the delegate method calls custom code to deliver that token to its parent server. In macOS, the method you use to register your interaction types is different, but the delegate methods you use to process registration are similar.</p>
</blockquote>
<p>表 2-2<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationDidFinishLaunching:(<span class="built_in">UIApplication</span> *)app &#123;</div><div class="line">    <span class="comment">// other setup tasks here....</span></div><div class="line">    </div><div class="line">    <span class="comment">// Register the supported interaction types.</span></div><div class="line">    <span class="built_in">UIUserNotificationType</span> types = <span class="built_in">UIUserNotificationTypeBadge</span> | <span class="built_in">UIUserNotificationTypeSound</span> | <span class="built_in">UIUserNotificationTypeAlert</span>;</div><div class="line">    <span class="built_in">UIUserNotificationSettings</span> *mySettings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:types categories:<span class="literal">nil</span>];</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:mySettings];</div><div class="line">    </div><div class="line">    <span class="comment">// Register for remote notifications.</span></div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Handle remote notification registration.</span></div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)app didRegisterForRemoteNotificationsWithDeviceToken:(<span class="built_in">NSData</span> *)devToken &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *devTokenBytes = [devToken bytes];</div><div class="line">    <span class="keyword">self</span>.registered = <span class="literal">YES</span>;</div><div class="line">    [<span class="keyword">self</span> sendProviderDeviceToken:devTokenBytes]; <span class="comment">// 将 deviceToken 传给自己后台服务器的自定义方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)app didFailToRegisterForRemoteNotificationsWithError:(<span class="built_in">NSError</span> *)err &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error in registration. Error: %@"</span>, err);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>application:didFailToRegisterForRemoteNotificationsWithError:</code> 的实现里，应该适当地处理错误对象，并禁止掉与远程通知相关的任何方面。因为通知有可能不能送达，所以最好是适当地降低风险，避免任何不必要的处理和展示这些通知的工作。</p>
<blockquote>
<p>In your <code>application:didFailToRegisterForRemoteNotificationsWithError:</code> implementation, you should process the error object appropriately and disable any features related to remote notifications. Because notifications are not going to be arriving anyway, it is usually better to degrade gracefully and avoid any unnecessary work needed to process or display those notifications.</p>
</blockquote>
<p>可控的通知可以让你在你的本地或远程通知的标准 iOS 界面上增加自定义的控制按钮。可控的通知可以让用户简单快捷地执行相关操作来回复通知。在 iOS 8 之前用户只有一种默认的通知控制。iOS 8 及以后的系统中，锁屏、通知状态栏和通知中心的通知入口可以展示一到两个自定义控制。模式警告可以展示4个。当用户选择一种自定义的控制时，iOS 会通知你的 app，这样你就可以通过该控制来执行操作。</p>
<blockquote>
<p>Actionable notifications let you add custom action buttons to the standard iOS interfaces for local and push notifications. Actionable notifications give the user a quick and easy way to perform relevant tasks in response to a notification. Prior to iOS 8, user notifications had only one default action. In iOS 8 and later, the lock screen, notification banners, and notification entries in Notification Center can display one or two custom actions. Modal alerts can display up to four. When the user selects a custom action, iOS notifies your app so that you can perform the task associated with that action.</p>
</blockquote>
<h3 id="Registering-Your-Actionable-Notification-Types"><a href="#Registering-Your-Actionable-Notification-Types" class="headerlink" title="Registering Your Actionable Notification Types"></a>Registering Your Actionable Notification Types</h3><blockquote>
<p>The configuration of custom actions depends on defining one or more categories for your notifications. Each category represents a type of notification that your app might receive, and you are responsible for defining the categories your app supports. For each category, you define the actions that a user might take when receiving a notification of that type. You then register your categories and actions with iOS using the same registerUserNotificationSettings: method you use to register the interaction types your app supports.</p>
<p>Each custom action consists of a button title and the information that iOS needs to notify your app when the action is selected. To create an action, create an instance of the UIMutableUserNotificationAction class and configure its properties appropriately. Listing 2-3 shows a code snippet for creating a single “accept” action. You create separate action objects for distinct action your app supports.</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIMutableUserNotificationAction</span> *acceptAction = [[<span class="built_in">UIMutableUserNotificationAction</span> alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// The identifier that you use internally to handle the action.</span></div><div class="line">acceptAction.identifier = <span class="string">@"ACCEPT_IDENTIFIER"</span>;</div><div class="line"></div><div class="line"><span class="comment">// The localized title of the action button.</span></div><div class="line">acceptAction.title = <span class="string">@"Accept"</span>;</div><div class="line"></div><div class="line"><span class="comment">// Specifies whether the app must be in the foreground to perform the action.</span></div><div class="line">acceptAction.activationMode = <span class="built_in">UIUserNotificationActivationModeBackground</span>;</div><div class="line"></div><div class="line"><span class="comment">// Destructive actions are highlighted appropriately to indicate their nature.</span></div><div class="line">acceptAction.destructive = <span class="literal">NO</span>;</div><div class="line"></div><div class="line"><span class="comment">// Indicates whether user authentication is required to perform the action.</span></div><div class="line">acceptAction.authenticationRequired = <span class="literal">NO</span>;</div></pre></td></tr></table></figure>
<h4 id="Defining-Your-Actionable-Notifications"><a href="#Defining-Your-Actionable-Notifications" class="headerlink" title="Defining Your Actionable Notifications"></a>Defining Your Actionable Notifications</h4><h4 id="Scheduling-an-Actionable-Notification"><a href="#Scheduling-an-Actionable-Notification" class="headerlink" title="Scheduling an Actionable Notification"></a>Scheduling an Actionable Notification</h4><h4 id="Handling-an-Actionable-Notification"><a href="#Handling-an-Actionable-Notification" class="headerlink" title="Handling an Actionable Notification"></a>Handling an Actionable Notification</h4><h3 id="Scheduling-Local-Notifications"><a href="#Scheduling-Local-Notifications" class="headerlink" title="Scheduling Local Notifications"></a>Scheduling Local Notifications</h3><p>在 iOS 系统中，创建一个 UILocalNotification 对象并用 UIApplication 的 <code>scheduleLocalNotification:</code> 方法来安排传送。</p>
<blockquote>
<p>In iOS, you create a UILocalNotification object and schedule its delivery using the <code>scheduleLocalNotification:</code> method of UIApplication. In macOS, you create an NSUserNotification object (which includes a delivery time) and the NSUserNotificationCenter is responsible for delivering it appropriately. (A macOS app can also adopt the NSUserNotificationCenterDelegate protocol to customize the behavior of the default NSUserNotificationCenter object.)</p>
<p>Creating and scheduling local notifications in iOS requires that you perform the following steps:</p>
<ol>
<li>In iOS 8 and later, register for notification types, as described in Registering Your iOS App’s Supported User Interaction Types. (In macOS and earlier versions of iOS, you need register only for remote notifications.) If you already registered notification types, call currentUserNotificationSettings to get the types of notifications the user accepts from your app.</li>
<li>Allocate and initialize a UILocalNotification object.</li>
<li>Set the date and time that the operating system should deliver the notification. This is the fireDate property.If you set the timeZone property to the NSTimeZone object for the current locale, the system automatically adjusts the fire date when the device travels across (and is reset for) different time zones. (Time zones affect the values of date components—that is, day, month, hour, year, and minute—that the system calculates for a given calendar and date value.) You can also schedule the notification for delivery on a recurring basis (daily, weekly, monthly, and so on).</li>
<li>As appropriate, configure an alert, icon badge, or sound so that the notification can be delivered to users according to their preferences. (To learn about when different notification types are appropriate, see Notifications.)<ul>
<li>An alert has a property for the message (the alertBody property) and for the title of the action button or slider (alertAction). Specify strings that are localized for the user’s current language preference. If your notifications can be displayed on Apple Watch, assign a value to the alertTitle property.</li>
<li>To display a number in a badge on the app icon, use the applicationIconBadgeNumber property.</li>
<li>To play a sound, assign a sound to the soundName property. You can assign the filename of a nonlocalized custom sound in the app’s main bundle (or data container) or you can assign UILocalNotificationDefaultSoundName to get the default system sound. A sound should always accompany the display of an alert message or the badging of an icon; a sound should not be played in the absence of other notification types.</li>
</ul>
</li>
<li>Optionally, you can attach custom data to the notification through the userInfo property. For example, a notification that’s sent when a CloudKit record changes includes the identifier of the record, so that a handler can get the record and update it.</li>
<li>Optionally, in iOS 8 and later, your local notification can present custom actions that your app can perform in response to user interaction, as described in Registering Your Actionable Notification Types.</li>
<li>Schedule the local notification for delivery.You schedule a local notification by calling scheduleLocalNotification:. The app uses the fire date specified in the UILocalNotification object for the moment of delivery. Alternatively, you can present the notification immediately by calling the presentLocalNotificationNow: method.</li>
</ol>
</blockquote>
<h3 id="Handling-Local-and-Remote-Notifications"><a href="#Handling-Local-and-Remote-Notifications" class="headerlink" title="Handling Local and Remote Notifications"></a>Handling Local and Remote Notifications</h3><p>让我们回顾一下当通知到达时的可能场景。</p>
<blockquote>
<p>Let’s review the possible scenarios that can arise when the system delivers a local notification or a remote notification for an app.</p>
</blockquote>
<p><strong>通知到达时 app 没有在前台。</strong>这种情况下，系统呈现通知，可能包括展示信息、应用程序图标小角标、播放声音、展示一个或多个控制按钮供用户点击。</p>
<blockquote>
<p><strong>The notification is delivered when the app isn’t running in the foreground.</strong> In this case, the system presents the notification, displaying an alert, badging an icon, perhaps playing a sound, and perhaps displaying one or more action buttons for the user to tap.</p>
</blockquote>
<p><strong>用户点击了一个 iOS 8 通知的自定义的控制按钮。</strong>这种情况下，iOS 调用 <code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code> 或 <code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>。</p>
<blockquote>
<p><strong>The user taps a custom action button in an iOS 8 notification.</strong> In this case, iOS calls either <code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code> or <code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>. In both methods, you get the identifier of the action so that you can determine which button the user tapped. You also get either the remote or local notification object, so that you can retrieve any information you need to handle the action.</p>
</blockquote>
<p><strong>用户点击了通知消息的默认按钮或点击了 app 的图标</strong></p>
<blockquote>
<p><strong>The user taps the default button in the alert or taps (or clicks) the app icon.</strong> If the default action button is tapped (on a device running iOS), the system launches the app and the app calls its delegate’s application:didFinishLaunchingWithOptions: method, passing in the notification payload (for remote notifications) or the local-notification object (for local notifications). Although application:didFinishLaunchingWithOptions: isn’t the best place to handle the notification, getting the payload at this point gives you the opportunity to start the update process before your handler method is called.</p>
<p>For remote notifications, the system also calls the application:didReceiveRemoteNotification:fetchCompletionHandler: method of the app delegate.</p>
<p>If the app icon is clicked on a computer running macOS, the app calls the delegate’s applicationDidFinishLaunching: method in which the delegate can obtain the remote-notification payload. If the app icon is tapped on a device running iOS, the app calls the same method, but furnishes no information about the notification.</p>
</blockquote>
<p><strong>通知到达时 app 运行在前台</strong></p>
<blockquote>
<p><strong>The notification is delivered when the app is running in the foreground.</strong> The app calls the application:didReceiveRemoteNotification:fetchCompletionHandler: or application:didReceiveLocalNotification: method of the app delegate. (If application:didReceiveRemoteNotification:fetchCompletionHandler: isn’t implemented, the system calls application:didReceiveRemoteNotification:.) In macOS, the system calls application:didReceiveRemoteNotification:.</p>
<p>n app can use the passed-in remote-notification payload or, in iOS, the UILocalNotification object to help set the context for processing the item related to the notification. Ideally, the delegate does the following on each platform to handle the delivery of remote and local notifications in all situations:</p>
<ul>
<li>For macOS, the delegate should adopt the NSApplicationDelegate protocol and implement the application:didReceiveRemoteNotification: method.</li>
<li>For iOS, the delegate should should adopt the UIApplicationDelegate protocol and implement the application:didReceiveRemoteNotification:fetchCompletionHandler: or application:didReceiveLocalNotification: methods. To handle notification actions, implement the application:handleActionWithIdentifier:forLocalNotification:completionHandler: or application:handleActionWithIdentifier:forRemoteNotification:completionHandler: methods.</li>
</ul>
<p>The delegate for an iOS app in Listing 2-11 implements the application:didFinishLaunchingWithOptions: method to handle a local notification. It gets the associated UILocalNotification object from the launch-options dictionary using the UIApplicationLaunchOptionsLocalNotificationKey key. From the UILocalNotification object’s userInfo dictionary, it accesses the to-do item that is the reason for the notification and uses it to set the app’s initial context. As shown in this example, you might appropriately reset the badge number on the app icon—or remove it if there are no outstanding items—as part of handling the notification.</p>
</blockquote>
<p>Listing 2-11  Handling a local notification when an app is launched<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    <span class="built_in">UILocalNotification</span> *localNotif = [launchOptions objectForKey:<span class="built_in">UIApplicationLaunchOptionsLocalNotificationKey</span>];</div><div class="line">    <span class="keyword">if</span> (localNotif) &#123;</div><div class="line">        <span class="built_in">NSString</span> *itemName = [localNotif.userInfo objectForKey:ToDoItemKey];</div><div class="line">        [viewController displayItem:itemName];  <span class="comment">// custom method</span></div><div class="line">        app.applicationIconBadgeNumber = localNotif.applicationIconBadgeNumber<span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    [window addSubview:viewController.view];</div><div class="line">    [window makeKeyAndVisible];</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>The implementation for a remote notification would be similar, except that you would use a specially declared constant in each platform as a key to access the notification payload:</p>
<ul>
<li>In iOS, the delegate, in its implementation of the application:didFinishLaunchingWithOptions: method, uses the UIApplicationLaunchOptionsRemoteNotificationKey key to access the payload from the launch-options dictionary.</li>
<li>In macOS, the delegate, in its implementation of the applicationDidFinishLaunching: method, uses the NSApplicationLaunchRemoteNotificationKey key to access the payload dictionary from the userInfo dictionary of the NSNotification object that is passed into the method.<br>The payload itself is an NSDictionary object that contains the elements of the notification—alert message, badge number, sound, and so on. It can also contain custom data the app can use to provide context when setting up the initial user interface. See The Remote Notification Payload for details about the remote-notification payload.</li>
</ul>
<p>Important: Delivery of remote notifications is not guaranteed, so you should not use the notification payload to deliver sensitive data or data that can’t be retrieved by other means.<br>One example of an appropriate usage for a custom payload property is a string identifying an email account from which messages are downloaded to an email client; the app can incorporate this string in its download user-interface. Another example of custom payload property is a timestamp for when the provider first sent the notification; the client app can use this value to gauge how old the notification is.</p>
<p>When handling remote notifications in your notification handling methods, the app delegate might perform a major additional task. Just after the app launches, the delegate should connect with its provider and fetch the waiting data.<br>Note: A client app should always communicate with its provider asynchronously or on a secondary thread.<br>The code in Listing 2-12 shows an implementation of the application:didReceiveLocalNotification: method which is called when app is running in the foreground. Here the app delegate does the same work as it does in Listing 2-11. It can access the UILocalNotification object directly this time because this object is an argument of the method.</p>
</blockquote>
<p>Listing 2-12  Handling a local notification when an app is already running<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)app didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notif &#123;</div><div class="line">    <span class="built_in">NSString</span> *itemName = [notif.userInfo objectForKey:ToDoItemKey];</div><div class="line">    [viewController displayItem:itemName];  <span class="comment">// custom method</span></div><div class="line">    app.applicationIconBadgeNumber = notification.applicationIconBadgeNumber - <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>If you want your app to catch remote notifications that the system delivers while it is running in the foreground, the app delegate must implement the application:didReceiveRemoteNotification:fetchCompletionHandler: method. The delegate should begin the procedure for downloading the waiting data, message, or other item and, after this concludes, it should remove the badge from the app icon. The dictionary passed in the second parameter of this method is the notification payload; you should not use any custom properties it contains to alter your app’s current context.</p>
</blockquote>
<h3 id="Scheduling-Location-Based-Local-Notifications"><a href="#Scheduling-Location-Based-Local-Notifications" class="headerlink" title="Scheduling Location-Based Local Notifications"></a>Scheduling Location-Based Local Notifications</h3><h4 id="Registering-for-Location-Based-Local-Notifications"><a href="#Registering-for-Location-Based-Local-Notifications" class="headerlink" title="Registering for Location-Based Local Notifications"></a>Registering for Location-Based Local Notifications</h4><h4 id="Handling-Core-Location-Callbacks"><a href="#Handling-Core-Location-Callbacks" class="headerlink" title="Handling Core Location Callbacks"></a>Handling Core Location Callbacks</h4><h4 id="Handling-Location-Based-Local-Notifications"><a href="#Handling-Location-Based-Local-Notifications" class="headerlink" title="Handling Location-Based Local Notifications"></a>Handling Location-Based Local Notifications</h4><h3 id="Preparing-Custom-Alert-Sounds"><a href="#Preparing-Custom-Alert-Sounds" class="headerlink" title="Preparing Custom Alert Sounds"></a>Preparing Custom Alert Sounds</h3><h3 id="Passing-the-Provider-the-Current-Language-Preference-Remote-Notifications"><a href="#Passing-the-Provider-the-Current-Language-Preference-Remote-Notifications" class="headerlink" title="Passing the Provider the Current Language Preference (Remote Notifications)"></a>Passing the Provider the Current Language Preference (Remote Notifications)</h3><h2 id="Apple-Push-Notification-Service-1"><a href="#Apple-Push-Notification-Service-1" class="headerlink" title="Apple Push Notification Service"></a>Apple Push Notification Service</h2><h2 id="Provisioning-and-Development"><a href="#Provisioning-and-Development" class="headerlink" title="Provisioning and Development"></a>Provisioning and Development</h2><h2 id="The-Remote-Notification-Payload"><a href="#The-Remote-Notification-Payload" class="headerlink" title="The Remote Notification Payload"></a>The Remote Notification Payload</h2><h2 id="APNs-Provider-API"><a href="#APNs-Provider-API" class="headerlink" title="APNs Provider API"></a>APNs Provider API</h2><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><h3 id="Binary-Provider-API"><a href="#Binary-Provider-API" class="headerlink" title="Binary Provider API"></a>Binary Provider API</h3><h3 id="Legacy-Notification-Format"><a href="#Legacy-Notification-Format" class="headerlink" title="Legacy Notification Format"></a>Legacy Notification Format</h3><h3 id="Document-Revision-History"><a href="#Document-Revision-History" class="headerlink" title="Document Revision History"></a>Document Revision History</h3>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Notifications/">Notifications</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/09/26/2016_09_26_Notifications/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/09/26/2016_09_26_Notifications/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/21/2016_09_21_DataPersistence/" title="数据化持久技术" itemprop="url">数据化持久技术</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-09-21T07:28:16.000Z" itemprop="datePublished"> 发表于 2016-09-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h2><p>NSUserDefaults 的生命周期是全局的，使用要慎重。</p>
<h3 id="将-NSUserDefaults-的某一项置空"><a href="#将-NSUserDefaults-的某一项置空" class="headerlink" title="将 NSUserDefaults 的某一项置空"></a>将 NSUserDefaults 的某一项置空</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUserDefaults</span> *defaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div><div class="line">[defaults removeObjectForKey:key];</div></pre></td></tr></table></figure>
<h3 id="一次清空-NSUserDefaults-所有内容"><a href="#一次清空-NSUserDefaults-所有内容" class="headerlink" title="一次清空 NSUserDefaults 所有内容"></a>一次清空 NSUserDefaults 所有内容</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *appDomain = [[<span class="built_in">NSBundle</span> mainBundle]bundleIdentifier];</div><div class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults]removePersistentDomainForName:appDomain];</div></pre></td></tr></table></figure>
<p>或用遍历的方式一项一项的清空：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUserDefaults</span>* defaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div><div class="line"><span class="built_in">NSDictionary</span>* dict = [defaults dictionaryRepresentation]; </div><div class="line"><span class="keyword">for</span>(<span class="keyword">id</span> key <span class="keyword">in</span> dict) &#123;</div><div class="line">    [defaults removeObjectForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="判断-NSUserDefaults-的某一项是否存在"><a href="#判断-NSUserDefaults-的某一项是否存在" class="headerlink" title="判断 NSUserDefaults 的某一项是否存在"></a>判断 NSUserDefaults 的某一项是否存在</h3><p>判断某个key是否存在，可以取出这个key的value，然后判断这个value是否有值，如果是数组，判断数组的count，如果是字符串判断length；</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/NSUserDefaults/">NSUserDefaults</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/09/21/2016_09_21_DataPersistence/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/09/21/2016_09_21_DataPersistence/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/18/2016_09_18_UIButton/" title="UIButton 笔记" itemprop="url">UIButton 笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-09-18T02:46:13.000Z" itemprop="datePublished"> 发表于 2016-09-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="UIEdgeInsets属性"><a href="#UIEdgeInsets属性" class="headerlink" title="UIEdgeInsets属性"></a>UIEdgeInsets属性</h2><h3 id="UIEdgeInsets"><a href="#UIEdgeInsets" class="headerlink" title="UIEdgeInsets"></a>UIEdgeInsets</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">UIEdgeInsets</span> &#123;</div><div class="line">    <span class="built_in">CGFloat</span> top, left, bottom, right;  <span class="comment">// specify amount to inset (positive) for each of the edges. values can be negative to 'outset'</span></div><div class="line">&#125; <span class="built_in">UIEdgeInsets</span>;</div></pre></td></tr></table></figure>
<p>UIButton的UIEdgeInsets相关属性有三个：</p>
<ol>
<li>contentEdgeInsets</li>
<li>imageEdgeInsets</li>
<li>titleEdgeInsets</li>
</ol>
<p>image 的 UIEdgeInsets 属性的top、left、bottom 都是相对于 button 的，right 是相对于 title；<br>title 的 UIEdgeInsets 属性的top、bottom、right 都是相对于 button 的，left 是相对于 image；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//拿到title和image的大小：</span></div><div class="line"><span class="built_in">CGSize</span> titleSize = <span class="keyword">self</span>.pureButton.titleLabel.bounds.size;</div><div class="line"><span class="built_in">CGSize</span> imageSize = <span class="keyword">self</span>.pureButton.imageView.bounds.size;</div><div class="line"><span class="comment">//分别设置偏移量:记住偏移量是位移</span></div><div class="line"><span class="keyword">self</span>.pureButton.titleEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, -imageSize.width, <span class="number">0</span>, imageSize.width);</div><div class="line"><span class="keyword">self</span>.pureButton.imageEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, titleSize.width, <span class="number">0</span>, -titleSize.width);</div></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define layoutCoefficient ([UIScreen mainScreen].bounds.size.width == 414 ? 1 : ([UIScreen mainScreen].bounds.size.width == 375 ? 0.91 : 0.77))</span></div><div class="line"></div><div class="line"><span class="built_in">CGFloat</span> offset = <span class="number">5.</span>;</div><div class="line">[<span class="keyword">self</span>.subscribeButton setImage:[[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"subscribe_gray"</span>]scaledToSize:<span class="built_in">CGSizeMake</span>(<span class="number">15</span> * layoutCoefficient, <span class="number">15</span> * layoutCoefficient)] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">[<span class="keyword">self</span>.subscribeButton setTitle:<span class="string">@"订阅"</span> forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">[<span class="keyword">self</span>.subscribeButton.titleLabel setFont:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">18</span> * layoutCoefficient]];</div><div class="line">[<span class="keyword">self</span>.subscribeButton setTitleColor:[<span class="built_in">UIColor</span> whiteColor] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line"><span class="keyword">self</span>.subscribeButton.contentEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> + offset);</div><div class="line"><span class="keyword">self</span>.subscribeButton.titleEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, offset, <span class="number">0</span>, -offset);</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/UIButton/">UIButton</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/09/18/2016_09_18_UIButton/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/09/18/2016_09_18_UIButton/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/08/2016_09_08_iOSPush/" title="iOS Push" itemprop="url">iOS Push</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-09-08T08:29:04.000Z" itemprop="datePublished"> 发表于 2016-09-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="http://mrpeak.cn/ios/2016/01/06/push" target="_blank" rel="external">iOS Push 门道</a></p>
</li>
<li><p><a href="https://leancloud.cn/docs/ios_push_cert.html" target="_blank" rel="external">iOS 推送证书设置指南</a></p>
</li>
<li><p><a href="http://superdanny.link/2016/02/02/iOS-Apple-Push-Notification-Service/" target="_blank" rel="external">iOS推送的那些事</a></p>
</li>
<li><p><a href="http://blog.csdn.net/showhilllee/article/details/8631734" target="_blank" rel="external">一步一步教你做 iOS 推送</a></p>
</li>
<li><p><a href="http://tanqisen.github.io/blog/2013/02/27/ios-push-apns/" target="_blank" rel="external">一步一步实现 iOS 应用 Push 功能</a></p>
</li>
<li><p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/APNsProviderAPI.html#//apple_ref/doc/uid/TP40008194-CH101-SW1" target="_blank" rel="external">【APNs Provider API】</a></p>
</li>
<li><p><a href="https://developer.apple.com/account/" target="_blank" rel="external">【Apple Developer 证书配置中心】</a></p>
</li>
<li><p><a href="http://blog.csdn.net/phunxm/article/details/42685597" target="_blank" rel="external">Apple 证书相关概念</a></p>
</li>
<li><p><a href="http://www.cocoachina.com/bbs/read.php?tid=195467" target="_blank" rel="external">Mac 上的消息推送测试工具 PushMeBaby</a></p>
</li>
<li><p><a href="http://io.diveinedu.com/2015/01/24/%E4%BD%BF%E7%94%A8PushMeBaby%E6%B5%8B%E8%AF%95APP%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD.html" target="_blank" rel="external">使用 PushMeBaby 测试 APP 的远程推送功能</a></p>
</li>
<li><p><a href="http://www.programgo.com/article/68982800051/;jsessionid=4DE852D70D7623B679B78CBD16EA45CB" target="_blank" rel="external">iOS 消息推送服务器的 Java 实现</a></p>
</li>
<li><p><a href="http://www.programgo.com/article/68982800051/;jsessionid=4DE852D70D7623B679B78CBD16EA45CB" target="_blank" rel="external">iOS 消息推送服务器的 Java 实现 Provider</a></p>
</li>
<li><p><a href="http://blog.handy.wang/blog/2013/12/19/mac-osxia-da-jian-apnstui-song-fu-wu-qi/" target="_blank" rel="external">iOS 消息推送服务器的 PHP 实现</a></p>
</li>
<li><p><a href="http://blog.csdn.net/tonny_guan/article/details/8963262" target="_blank" rel="external">推送通知 iOS 客户端编写实现及推送服务器端编写</a></p>
</li>
<li><p><a href="http://docs.jiguang.cn/jpush/client/iOS/ios_guide_new/" target="_blank" rel="external">JPush iOS SDK 集成指南</a></p>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>iOS Push 流程涉及到四个角色：<code>Device</code>、<code>APP</code>、<code>Provider</code>、<code>APNs</code></p>
<p><strong>Device：</strong>iOS设备，用来接收 APNs 下发下来的消息</p>
<p><strong>Client App：</strong>iOS 设备上的应用程序，用来接收 APNs 下发的消息到指定的一个客户端 app (消息的最终响应者)</p>
<p><strong>Provider：</strong>我们自己搭建的 APP Push服务器</p>
<p><strong>APNs：</strong>苹果的服务器（Apple Push Notification Service）</p>
<h3 id="deviceToken"><a href="#deviceToken" class="headerlink" title="deviceToken"></a>deviceToken</h3><p>deviceToken 唯一标识一个用户。在使用推送功能的时候，需要在开发者中心创建支持Push Notification的证书，并且将证书和私钥用于应用后台服务器与APNs之间通信。</p>
<ul>
<li>在一台设备中，deviceToken 是系统级别的，不同 App 获得的 deviceToken 是相同的。</li>
<li>deviceToken 并不会因为单个 app 的更新而发生改变。</li>
<li>假如我的 iPhone 从 backup 中恢复数据，deviceToken 不会发生变化。</li>
<li>用户抹除 iPhone 的数据时，意味着要与这台手机撇清关系，比如出售或者送人。此时为了保护隐私，deviceToken 会改变。</li>
<li>老老实实的收集最新的 deviceToken，这是最保险的做法。</li>
<li>Development 和 Production 两个版本下的 deviceToken 是不同的，前者是由 <a href="https://developer.apple.com/account/ios/profile/" target="_blank" rel="external">Certificates, Identifiers &amp; Profiles</a> -&gt; Provisioning Profiles -&gt; Development 下的 *.mobileprovision 获取的。后者是由 <a href="https://developer.apple.com/account/ios/profile/" target="_blank" rel="external">Certificates, Identifiers &amp; Profiles</a> -&gt; Provisioning Profiles -&gt; Production 的 *.mobileprovision 获取的。</li>
<li>app 端发送 deviceToken 给“自建 push 服务器”的时机：获取 deviceToken 之后立刻发送。</li>
</ul>
<p>参考<a href="http://www.mednoter.com/device-token.html" target="_blank" rel="external">不同App获得的device token是否相同？</a></p>
<h3 id="deviceToken-的获取方法"><a href="#deviceToken-的获取方法" class="headerlink" title="deviceToken 的获取方法"></a>deviceToken 的获取方法</h3><ul>
<li><p>在 AppDelegate 文件里的 <code>application:didFinishLaunchingWithOptions:</code> 方法里注册 RemoteNotifications</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 注册 RemoteNotifications</span></div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([application respondsToSelector:<span class="keyword">@selector</span>(registerUserNotificationSettings:)]) &#123;</div><div class="line">        <span class="comment">// iOS 8 and later</span></div><div class="line">        <span class="built_in">UIUserNotificationSettings</span> *settings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:</div><div class="line">                                                <span class="built_in">UIUserNotificationTypeAlert</span> | <span class="built_in">UIUserNotificationTypeBadge</span> |</div><div class="line">                                                <span class="built_in">UIUserNotificationTypeSound</span> categories:<span class="literal">nil</span>];</div><div class="line">        [<span class="built_in">UIApplication</span>.sharedApplication registerUserNotificationSettings:settings];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// iOS 7 and earlier</span></div><div class="line">        [<span class="built_in">UIApplication</span>.sharedApplication registerForRemoteNotificationTypes:</div><div class="line">         <span class="built_in">UIRemoteNotificationTypeAlert</span> | <span class="built_in">UIRemoteNotificationTypeBadge</span> |</div><div class="line">         <span class="built_in">UIRemoteNotificationTypeSound</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// app启动后自动清除IconBadgeNumber</span></div><div class="line">    [<span class="built_in">UIApplication</span> sharedApplication].applicationIconBadgeNumber = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在回调方法 <code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code> 里获取 deviceToken</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didRegisterForRemoteNotificationsWithDeviceToken:(<span class="built_in">NSData</span> *)deviceToken &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"deviceToken = %@"</span>, deviceToken);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p><img src="/images/2016_09_08_iOSPush-PushSequence1.jpg"><br><img src="/images/2016_09_08_iOSPush-PushSequence2.png" width="80%"></p>
<blockquote>
<p>notification 传递的三个阶段：</p>
<ul>
<li><p>第一阶段：我们自己的后台服务器上的 Provider 程序把要发送的通知、目标 iPhone 的 deviceToken（相当于该设备的唯一标识）打包，发给APNs。 </p>
</li>
<li><p>第二阶段：APNs 在自己已注册 Push 服务的 iPhone 列表中，查找对应 deviceToken 的 iPhone，并把 Push 通知发送到该 iPhone 上。 </p>
</li>
<li><p>第三阶段：iPhone 将接收到的 Push 通知传递给相应的应用程序，并且按照设定弹出 Push 通知。</p>
</li>
</ul>
</blockquote>
<hr>
<p><img src="/images/2016_09_08_iOSPush-PushSequence3.png" width="60%"></p>
<blockquote>
<p>Push 的工作流程：</p>
<ol>
<li><p>Device – 请求 –&gt; APNs：获取 deviceToken</p>
</li>
<li><p>Device – 提供 –&gt; Provider：提供 deviceToken</p>
</li>
<li><p>Provider 根据需要生成需要 push 的 notification 信息</p>
</li>
<li><p>Provider 把要 push 的 notification 消息推送到 APNs</p>
</li>
<li><p>APNs 把该 notification 消息推送到手机</p>
</li>
</ol>
</blockquote>
<h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p>服务器配置好证书并拿到 deviceToken 后就可以向 APNs 发送消息了。苹果官方是这么介绍 Payload 的：<strong>The payload contains the custom data you want to provide, along with information about how the system should alert the user.</strong> 发送消息的格式如下图所示：<br><img src="/images/2016_09_08_iOSPush-Payload.jpg"></p>
<p>Payload 就是 push 的消息负载，这就是应用需要关心的数据。 Payload 是一个 JSON 字典，该字典必须包含一个 key 为 aps 的字典，aps 字典可以包含 alert、badge、sound 三个属性中的一个或多个，alert 为展示给用户的消息，badge 表示应用程序图标显示的数字，sound 表示收到 push 的提示音。基本格式如下：</p>
<pre><code>{
    &quot;aps&quot;: {
      &quot;alert&quot;:&quot;Hello Push!&quot;,
      &quot;badge&quot;:1,
      &quot;sound&quot;:&quot;default&quot;
    }
 }
</code></pre><p>Payload 是有大小限制的，超过这个限制，APNs 将拒绝转发。其限制与所使用的 APNs provider API 有关：</p>
<ul>
<li>HTTP/2-based APNs provider API<br>  Regular push notification: 4KB<br>  Voice over Internet Protocol (VoIP) notification: 5KB</li>
<li>Legacy APNs binary interface<br>  Regular push notification: 2KB）<br>Payload 的具体结构参考 <a href="https://developer.apple.com/library/prerelease/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/TheNotificationPayload.html#//apple_ref/doc/uid/TP40008194-CH107-SW1" target="_blank" rel="external">Apple Push Notification Service</a></li>
</ul>
<h2 id="客户端接收-push-消息"><a href="#客户端接收-push-消息" class="headerlink" title="客户端接收 push 消息"></a>客户端接收 push 消息</h2><p>iOS系统收到push消息后，如果用户点击查看，系统将根据证书启动相应应用。如果应用已经启动，将调用AppDelegate的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo &#123;</div><div class="line">    <span class="comment">// userInfo 就是push消息的Payload</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果应用还没有启动，通过push冷启动后，仍然能在启动后获取Payload：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    <span class="built_in">NSDictionary</span>* userInfo = [launchOptions objectForKey:<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Payload: %@"</span>, userInfo);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当Payload设置了badge，应用图标上将一直显示一个数字提示，如果要清除数字提示，或者设置成其他数字，调用下面函数就可以完成。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] setApplicationIconBadgeNumber:number];</div></pre></td></tr></table></figure></p>
<p>number为0就会清除数字提示。</p>
<p>如果 APP 处于非运行状态，当通知到达时，alert message、sound、badge value 直接展示，如果 APP 处于运行状态，则通知消息将以 NSDictionary 的方式传给 delegate 方法。</p>
<h2 id="APNs-server"><a href="#APNs-server" class="headerlink" title="APNs server:"></a>APNs server:</h2><ul>
<li><strong>Development server:</strong> <code>api.development.push.apple.com:443</code></li>
<li><strong>Production server:</strong> <code>api.push.apple.com:443</code></li>
</ul>
<h2 id="APP-不在前台"><a href="#APP-不在前台" class="headerlink" title="APP 不在前台"></a>APP 不在前台</h2><p>当 APP 没有运行在前台时，点击通知后，iOS 系统会打开 APP，并调用 <strong>application:didFinishLaunchingWithOptions:</strong> 方法，并将通知消息传递给 options 参数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions;</div></pre></td></tr></table></figure></p>
<p>同时还会调用 <strong>application:didReceiveRemoteNotification:fetchCompletionHandler:</strong> 方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler;</div></pre></td></tr></table></figure></p>
<h2 id="APP-在前台"><a href="#APP-在前台" class="headerlink" title="APP 在前台"></a>APP 在前台</h2><p>iOS 不会展示通知，而是调用 <strong>application:didReceiveRemoteNotification: </strong> 和 <strong>application:didReceiveRemoteNotification:fetchCompletionHandler:</strong> 两个方法中的一个（哪个实现了调用哪个）。</p>
<p>为了能够 handle the custom actions in iOS 8 or newer，还得实现 <strong>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</strong> 方法。<br>You receive the action identifier, which you can use to determine what action was tapped. You also receive the notification, which you can use to retrieve any information you need to handle that action. Finally, the system passes you the completion handler, which you must call when you finish handling the action. </p>
<h2 id="APP-在前台-1"><a href="#APP-在前台-1" class="headerlink" title="APP 在前台"></a>APP 在前台</h2><p>当 APP 在前台时，Notification 有两种传输方式：<code>自研通道</code>、<code>APNs通道</code>，默认走<code>自研通道</code></p>
<h3 id="自研通道"><a href="#自研通道" class="headerlink" title="自研通道"></a>自研通道</h3><ol>
<li><p>获得 Notification：</p>
<blockquote>
<ul>
<li><p>在 PSPushServiceDelegate 的代理方法<code>onRecvMessage:</code>里直接获得 Notification：</p>
<pre><code>- (void)onRecvMessage:(PSPushMessage *)message
</code></pre></li>
<li><p>PSPushMessage 有三个属性，其中 msgBody 即为需要的 Notification</p>
</li>
</ul>
</blockquote>
</li>
<li><p>处理 Notification：</p>
<blockquote>
<p>有两种处理 Notification 的方法：</p>
<ol>
<li><p>弹窗</p>
</li>
<li><p>LocalNotification</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="APNs通道"><a href="#APNs通道" class="headerlink" title="APNs通道"></a>APNs通道</h3><ul>
<li>有两个代理方法获得并处理 Notification：<blockquote>
<pre><code>- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo
</code></pre><p>和</p>
<pre><code>-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
</code></pre><p>若同时实现了两个方法，则只执行 application:didReceiveRemoteNotification:fetchCompletionHandler: 方法</p>
</blockquote>
</li>
</ul>
<h1 id="APP-在后台"><a href="#APP-在后台" class="headerlink" title="APP 在后台"></a>APP 在后台</h1><p>当 APP 在后台时，Notification 默认走<code>APNs通道</code>，当<code>APNs通道</code>走不通时也会走<code>自研通道</code>，Notification 的获取流程如下：</p>
<ol>
<li>直接展示 Notification：alert、badge、sound</li>
<li>在 APP <code>冷启动</code>时把 Notification 通过 didFinishLaunchingWithOptions: 传递给 launchOptions 参数，冷启动意味着在测试时无法获取 Notification<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
</code></pre></li>
<li>（不管是冷启动还是热启动）同时还会调用 application:didReceiveRemoteNotification:fetchCompletionHandler: 方法，userInfo 即为需要的 Notification，在该方法中处理 Notification<pre><code>-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
</code></pre></li>
</ol>
<p>注：</p>
<ul>
<li>必须是以点击通知的方式打开 APP，而不能直接打开 APP    ，否则无法获得 Notification</li>
<li>application:didReceiveRemoteNotification:fetchCompletionHandler: 好像是 iOS 8以后才有的方法，所以当 APP 在后台时，对于 iOS 8 以前的设备只能通过步骤 2 来处理</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Push/">Push</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/09/08/2016_09_08_iOSPush/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/09/08/2016_09_08_iOSPush/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/29/2016_08_29_UINavigationControllerNote/" title="UINavigationController + UINavigationBar + UIWebView 范例" itemprop="url">UINavigationController + UINavigationBar + UIWebView 范例</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-08-29T02:24:53.000Z" itemprop="datePublished"> 发表于 2016-08-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="UINavigationBar-UIWebView-范例"><a href="#UINavigationBar-UIWebView-范例" class="headerlink" title="UINavigationBar + UIWebView 范例"></a>UINavigationBar + UIWebView 范例</h2><h3 id="目录结构如下："><a href="#目录结构如下：" class="headerlink" title="目录结构如下："></a>目录结构如下：</h3><!--![UINavigationBarDictionary](/images/2016-08-29-UINavigationControllerNote-UINavigationBarDictionary.png)-->
<p><img src="/images/2016-08-29-UINavigationControllerNote-UINavigationBarDictionary.png" width="30%"></p>
<h3 id="ViewController-m文件"><a href="#ViewController-m文件" class="headerlink" title="ViewController.m文件"></a>ViewController.m文件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#define SCREENWIDTH [UIScreen mainScreen].bounds.size.width</span></div><div class="line"><span class="meta">#define SCREENHEIGHT [UIScreen mainScreen].bounds.size.height</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">UIWebViewDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIWebView</span> *webView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UINavigationBar</span> *navigationBar;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 创建UINavigationBar</span></div><div class="line">    <span class="keyword">self</span>.navigationBar = [[<span class="built_in">UINavigationBar</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">20</span>, SCREENWIDTH, <span class="number">44</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">// 这里直接设置UINavigationBar的backgroundColor是没效果的</span></div><div class="line">    <span class="comment">// self.navigationBar.backgroundColor = [UIColor purpleColor];</span></div><div class="line">    </div><div class="line">    <span class="comment">// 设置UINavigationBar的背景色</span></div><div class="line">    <span class="keyword">self</span>.navigationBar.barTintColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置UINavigationBar的UINavigationItem的颜色</span></div><div class="line">    <span class="keyword">self</span>.navigationBar.tintColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">// 为UINavigationBar添加UINavigationItem，并设置UINavigationItem的UIBarButtonItem</span></div><div class="line">    <span class="built_in">UINavigationItem</span> *navigationItem = [[<span class="built_in">UINavigationItem</span> alloc] initWithTitle:<span class="string">@"美团抢鲜"</span>];</div><div class="line">    <span class="built_in">UIBarButtonItem</span> *leftButton = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithBarButtonSystemItem:<span class="built_in">UIBarButtonSystemItemReply</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(webViewGoBack)];</div><div class="line">    <span class="built_in">UIBarButtonItem</span> *rightButton = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithBarButtonSystemItem:<span class="built_in">UIBarButtonSystemItemPlay</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(webViewGoForward)];</div><div class="line">    [navigationItem setLeftBarButtonItem:leftButton];</div><div class="line">    [navigationItem setRightBarButtonItem:rightButton];</div><div class="line">    <span class="comment">// 最后别忘了把设置好的UINavigationItem添加到UINavigationBar上</span></div><div class="line">    [<span class="keyword">self</span>.navigationBar pushNavigationItem:navigationItem animated:<span class="literal">YES</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置UIWebView</span></div><div class="line">    <span class="keyword">self</span>.webView = [[<span class="built_in">UIWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, SCREENWIDTH, SCREENHEIGHT)];</div><div class="line">    <span class="keyword">self</span>.webView.delegate = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 下面两句是UI测试专用方法</span></div><div class="line">    <span class="comment">// self.webView.layer.borderColor = [[UIColor redColor] CGColor];</span></div><div class="line">    <span class="comment">// self.webView.layer.borderWidth = 1;</span></div><div class="line">    </div><div class="line">    <span class="comment">// 设置UIWebView后面的View的背景色，而不是直接设置到UIWebView上</span></div><div class="line">    <span class="comment">// self.webView.backgroundColor = [UIColor brownColor];</span></div><div class="line">    </div><div class="line">    <span class="comment">// 如若url的scheme是http，还要在Info.plist中设置NSAppTransportSecurity的NSAllowsArbitraryLoads字段</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://liu2er.com/"</span>];</div><div class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.webView];</div><div class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.navigationBar];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.webView loadRequest:request];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 左上角返回按钮</span></div><div class="line">-(<span class="keyword">void</span>)webViewGoBack &#123;</div><div class="line">    [<span class="keyword">self</span>.webView goBack];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 右上角前进按钮</span></div><div class="line">-(<span class="keyword">void</span>)webViewGoForward &#123;</div><div class="line">    [<span class="keyword">self</span>.webView goForward];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="UINavigationController-UIWebView-范例"><a href="#UINavigationController-UIWebView-范例" class="headerlink" title="UINavigationController + UIWebView 范例"></a>UINavigationController + UIWebView 范例</h2><h3 id="目录结构如下：-1"><a href="#目录结构如下：-1" class="headerlink" title="目录结构如下："></a>目录结构如下：</h3><!--![UINavigationBarDictionary](/images/2016-08-29-UINavigationControllerNote-UINavigationBarDictionary.png)-->
<p><img src="/images/2016-08-29-UINavigationControllerNote-UINavigationControllerDictionary.png" width="30%"></p>
<h3 id="AppDelegate-m文件"><a href="#AppDelegate-m文件" class="headerlink" title="AppDelegate.m文件"></a>AppDelegate.m文件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UINavigationController</span> *navigationVC;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) ViewController *webVC;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.webVC = [[ViewController alloc] init];</div><div class="line">    <span class="keyword">self</span>.navigationVC = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:<span class="keyword">self</span>.webVC];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置navigationBar是否半透明，YES半透明，NO不半透明</span></div><div class="line">    [<span class="keyword">self</span>.navigationVC.navigationBar setTranslucent:<span class="literal">NO</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.window.rootViewController = <span class="keyword">self</span>.navigationVC;</div><div class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="ViewController-m文件-1"><a href="#ViewController-m文件-1" class="headerlink" title="ViewController.m文件"></a>ViewController.m文件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#define SCREENWIDTH [UIScreen mainScreen].bounds.size.width</span></div><div class="line"><span class="meta">#define SCREENHEIGHT [UIScreen mainScreen].bounds.size.height</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">UIWebViewDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIWebView</span> *webView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.navigationItem.title=<span class="string">@"TestFlightApp"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.navigationItem.leftBarButtonItem = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithBarButtonSystemItem:<span class="built_in">UIBarButtonSystemItemReply</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(webViewGoBack)];</div><div class="line">    <span class="keyword">self</span>.navigationItem.rightBarButtonItem = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithBarButtonSystemItem:<span class="built_in">UIBarButtonSystemItemPlay</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(webViewGoForward)];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.webView = [[<span class="built_in">UIWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">-64</span>, SCREENWIDTH, SCREENHEIGHT)];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.webView.delegate = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://liu2er.com/"</span>];	    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.webView];</div><div class="line">    [<span class="keyword">self</span>.webView loadRequest:request];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 左上角返回按钮</span></div><div class="line">-(<span class="keyword">void</span>)webViewGoBack &#123;</div><div class="line">    [<span class="keyword">self</span>.webView goBack];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 右上角前进按钮</span></div><div class="line">-(<span class="keyword">void</span>)webViewGoForward &#123;</div><div class="line">    [<span class="keyword">self</span>.webView goForward];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>注：如若需要在UIWebView里用到http的明文链接，则需要设置<code>Info.plist</code>的<code>App Transport Security Settings</code>参数，即：</p>
<ul>
<li>在Info.plist中添加<code>App Transport Security Settings</code>类型Dictionary；</li>
<li>在App Transport Security Settings下添加<code>NSAllowsArbitraryLoads</code>类型Boolean,值设为<code>YES</code>；<br>如下图所示：<br><img src="/images/2016-08-29-UINavigationControllerNote-AppTransportSecuritySettings.png" width="60%"></li>
</ul>
<p>具体操作参考<a href="https://segmentfault.com/a/1190000002933776" target="_blank" rel="external">iOS9 HTTP 不能正常使用的解决办法</a>。</p>
<p><strong>UIBarButtonSystemItem：</strong><br><img src="/images/2016-08-29-UINavigationControllerNote-UIBarButtonSystemItem.png" width="40%"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/UINavigationController/">UINavigationController</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/29/2016_08_29_UINavigationControllerNote/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/29/2016_08_29_UINavigationControllerNote/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/25/2016_08_25_RACPractice/" title="RAC 工程简单实践" itemprop="url">RAC 工程简单实践</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-08-25T03:33:48.000Z" itemprop="datePublished"> 发表于 2016-08-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="创建一个简单的-RAC-工程"><a href="#创建一个简单的-RAC-工程" class="headerlink" title="创建一个简单的 RAC 工程"></a>创建一个简单的 RAC 工程</h2><ul>
<li>先创建一个 SigleView 或 Command Line Tool 工程 <code>RACTest</code></li>
<li>在 RACTest 工程的根目录执行终端命令：<code>$ vim Podfile</code></li>
<li>在 Podfile 里写入内容：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">platform <span class="symbol">:ios</span>, <span class="string">'9.0'</span>  <span class="comment">#这条命令不是必须的</span></div><div class="line">pod <span class="string">"ReactiveCocoa"</span>, <span class="string">"2.5"</span>  <span class="comment">#3.0版本不成功，2.5和~&gt;4.0.4-alpha-4都能成功</span></div><div class="line">use_frameworks!  <span class="comment">#这条命令不是必须的</span></div></pre></td></tr></table></figure>
<ul>
<li>在 RACTest 工程的根目录执行终端命令：<code>$ pod install —-no-repo-update</code></li>
<li>在 RACTest 工程里导入头文件 <code>#import &quot;ReactiveCocoa/ReactiveCocoa.h&quot;</code></li>
</ul>
<h2 id="最简单的信号的创建与订阅范例"><a href="#最简单的信号的创建与订阅范例" class="headerlink" title="最简单的信号的创建与订阅范例"></a>最简单的<em>信号的创建与订阅</em>范例</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"ReactiveCocoa/ReactiveCocoa.h"</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 创建信号</span></div><div class="line">        RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// 发送信号</span></div><div class="line">            [subscriber sendNext:<span class="string">@"数据1"</span>];</div><div class="line">            [subscriber sendNext:<span class="string">@"数据2"</span>];</div><div class="line">            [subscriber sendError:[<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"SignalError"</span> code:<span class="number">110</span> userInfo:@&#123;<span class="string">@"reason"</span>:<span class="string">@"unknown"</span>&#125;]];</div><div class="line">            [subscriber sendCompleted];</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line">                <span class="built_in">NSLog</span>(<span class="string">@"信号被销毁"</span>);</div><div class="line">            &#125;];</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">        <span class="comment">// 订阅信号</span></div><div class="line">        [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"接收到数据：%@"</span>, x);</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为：</p>
<pre><code>2016-08-24 17:25:57.107 OCTest[15943:240697] 接收到数据：数据1
2016-08-24 17:25:57.108 OCTest[15943:240697] 接收到数据：数据2
2016-08-24 17:25:57.108 OCTest[15943:240697] 信号被销毁
Program ended with exit code: 0
</code></pre><h2 id="CocoaPods使用技巧"><a href="#CocoaPods使用技巧" class="headerlink" title="CocoaPods使用技巧"></a>CocoaPods使用技巧</h2><ul>
<li>在工程根目录下执行<code>$ pod init</code>命令可以初始化一个 Podfile 文件</li>
<li>CocoaPods 使用 Ruby 语言编写而成，OS X 已经集成了 Ruby 环境</li>
<li>查看 Ruby 源<code>$ gem source -l</code></li>
<li>通过添加 verbose 参数来参看 pod install 过程<code>$ pod install —-verbose —-no-repo-update</code></li>
<li><p>可以搜索框架，例如<code>$ pod search ReactiveCocoa</code>，搜索到 ReactiveCocoa 的所有版本如下：</p>
<p>  4.2.1, 4.1.0, 4.0.4-alpha-4, 4.0.4-alpha-1, 4.0.3-alpha-3, 4.0.3-alpha-1, 4.0.2-alpha-3, 4.0.2-alpha-1, 4.0.1, 4.0.1-alpha-3, 4.0.1-alpha-1, 4.0.0, 4.0.0-alpha-3, 4.0.0-alpha-2, 4.0.0-alpha-1, 4.0.0-RC.2, 4.0.0-RC.1, 3.0.0, 3.0.0-swift2, 3.0-beta.9, 3.0-beta.6, 3.0-alpha.3, 3.0.0-alpha.1, 3.0-RC.1, 2.5, 2.4.7, 2.4.6, 2.4.5, 2.4.4, 2.4.2, 2.3.1, 2.3, 2.2.4, 2.2.3, 2.2.2, 2.2, 2.1.8, 2.1.7, 2.1.6, 1.4.0, 1.3.1, 1.0.0, 0.17.1, 0.16.1, 0.13.1, 0.12.0, 0.10.0, 0.9.0, 0.8.0, 0.6.0, 0.5.0, 0.0.1 [master-1 repo]</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/RAC/">RAC</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/25/2016_08_25_RACPractice/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/25/2016_08_25_RACPractice/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/25/2016_08_25_HexoNote/" title="Hexo + Jacman 笔记" itemprop="url">Hexo + Jacman 笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-08-25T02:19:35.000Z" itemprop="datePublished"> 发表于 2016-08-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Hexo-Jacman安装流程"><a href="#Hexo-Jacman安装流程" class="headerlink" title="Hexo + Jacman安装流程"></a>Hexo + Jacman安装流程</h2><ul>
<li>去 <a href="https://nodejs.org/en/" target="_blank" rel="external">node.js 官网</a>安装<code>node.js</code></li>
<li>查看版本号<code>$ node -v</code> 和 <code>$ npm -v</code></li>
<li>去 <a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">homebrew 官网</a>下载并安装<code>homebrew</code></li>
<li>检查是否已经安装过 hexo <code>$ hexo -v</code></li>
<li>如果没安装过 hexo，运行命令安装 <code>$ sudo npm install -g hexo-cli</code>，参考 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo 官网</a></li>
<li>新建博客存放目录<code>&lt;blog_directory&gt;</code></li>
<li><code>$ hexo init &lt;blog_directory&gt;</code></li>
<li>cd 到 <code>&lt;blog_directory&gt;</code> 目录执行<code>$ npm install</code></li>
<li>先后执行<code>$ hexo generate</code>（简写 hexo g）和<code>$ hexo server</code>（简写 hexo s）启动站点，然后在浏览器中输入<code>http://0.0.0.0:4000</code>就可以看到站点了</li>
<li>设置 <code>Github Pages</code>，可以参考<a href="http://my.oschina.net/ryaneLee/blog/638440" target="_blank" rel="external">小白独立搭建博客–Github Pages和Hexo简明教程</a>和<a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="external">史上最详细的Hexo博客搭建图文教程</a></li>
<li>查看<code>~/.ssh</code>目录中是否已经存在 SSH key 了，如果存在了则直接用，如果没有存在则重新配置<blockquote>
<p><code>$ git config --global user.name “yourname”</code><br><code>$ git config --global user.email “youremail”</code><br>注：本邮箱不一定与 github 的注册邮箱一致，但是应该与 SSH key 的邮箱一致</p>
</blockquote>
</li>
<li>测试 SSH key 是否设置成功<code>$ ssh -T git@github.com</code></li>
<li>如下图所示配置_config.yml文件：<br><img src="/images/2016-08-25-HexoNote-DeployGitSetting.png" width="50%"><!--![DeployGitSetting](/images/2016-08-25-HexoNote-DeployGitSetting.png)--></li>
<li>如果使用 git 方式进行部署，执行<code>$ npm install hexo-deployer-git --save</code>来安装所需的插件</li>
<li>也可以用 https 方式来部署，如下图所示：<br><img src="/images/2016-08-25-HexoNote-DeployHttpsSetting.png" width="50%"><!--![DeployHttpsSetting](/images/2016-08-25-HexoNote-DeployHttpsSetting.png)--></li>
<li>用 https 方式部署时需要输入 github 的注册邮箱和登录密码</li>
<li>最后执行<code>$ hexo g -d</code>来发布</li>
<li>在博客根目录下执行如下命令来安装 jacman 主题<code>$ git clone https://github.com/wuchong/jacman.git themes/Jacman</code></li>
<li>在<code>_config.yml</code>文件中设置 theme 为 Jacman</li>
</ul>
<h2 id="文章发布流程"><a href="#文章发布流程" class="headerlink" title="文章发布流程"></a>文章发布流程</h2><blockquote>
<ol>
<li><code>hexo new &lt;文章名&gt;</code>  // Create a new post &lt;文章名&gt;，缩写<code>hexo n &lt;文章名&gt;</code></li>
<li><code>hexo generate</code>  // Generate static files</li>
<li><code>hexo deploy</code>  // Deploy to remote sites</li>
</ol>
</blockquote>
<ul>
<li>其中<code>hexo generate</code>和<code>hexo deploy</code>可以合成一条命令，即<code>hexo generate -d</code>或<code>hexo deploy -g</code>，简写为<code>hexo g -d</code>或<code>hexo d -g</code>。</li>
<li>在部署之前可以使用<code>hexo server</code>命令来启动服务器在本地预览。</li>
<li>文章的默认生成路径为<code>~/Documents/Hexo文件/source/_posts/&lt;文章名&gt;.md</code>。</li>
<li>hexo常用命令可以参考<a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="external">hexo常用命令笔记</a>。</li>
</ul>
<h2 id="代码段高亮"><a href="#代码段高亮" class="headerlink" title="代码段高亮"></a>代码段高亮</h2><p>首先，设置<code>~/Documents/Hexo文件/_config.yml</code></p>
<!--![CodeHighlightSetting](/images/2016-08-25-HexoNote-CodeHighlightSetting.png)-->
<p><img src="/images/2016-08-25-HexoNote-CodeHighlightSetting.png" width="20%"></p>
<p>其次，设置文件<code>~/Documents/Hexo文件/themes/Jacman/source/css/_base/highlight/theme.styl</code>，设置前图片如下所示：</p>
<!--![CommentColor](/images/2016-08-25-HexoNote-CommentColor.png)-->
<p><img src="/images/2016-08-25-HexoNote-CommentColor.png" width="40%" height="40%"></p>
<p>例如把代码块默认主题注释字段的颜色修改为<code>#00A86B</code>。</p>
<p>写代码时格式为：</p>
<blockquote>
<p>```objc</p>
<p>代码</p>
<p>```</p>
</blockquote>
<p>其中hexo支持的语言样式颜色可以参考<a href="http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html" target="_blank" rel="external">CSS classes reference</a>，Markdown语法可参考文章<a href="https://coding.net/help/doc/project/markdown.html#section-8" target="_blank" rel="external">Markdown语法介绍</a>，另外可参考文章<a href="http://vin-zhou.github.io/2014/10/23/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">Hexo搭建个人博客</a>。</p>
<h2 id="控制图片大小"><a href="#控制图片大小" class="headerlink" title="控制图片大小"></a>控制图片大小</h2><p>Markdown目前不支持调整图片大小，如果有这样的需求，可以直接用html代码插入，例如：</p>
<pre><code>&lt;img src=&quot;xxx.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;
或
&lt;img src=&quot;xxx.jpg&quot; width=&quot;50%&quot; /&gt;
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Blog/">Blog</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Hexo/">Hexo</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/25/2016_08_25_HexoNote/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/25/2016_08_25_HexoNote/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/24/2016_08_25_ReactiveCocoaNote/" title="ReactiveCocoa 学习笔记" itemprop="url">ReactiveCocoa 学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-08-24T10:45:18.000Z" itemprop="datePublished"> 发表于 2016-08-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="RACSignal创建方式"><a href="#RACSignal创建方式" class="headerlink" title="RACSignal创建方式"></a>RACSignal创建方式</h2><h3 id="单元信号"><a href="#单元信号" class="headerlink" title="单元信号"></a>单元信号</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal1 = [RACSignal <span class="keyword">return</span>:<span class="string">@"Some Value"</span>];</div><div class="line">RACSignal *signal2 = [RACSignal error:errorObject];</div><div class="line">RACSignal *signal3 = [RACSignal empty];</div><div class="line">RACSignal *signal4 = [RACSignal never];</div></pre></td></tr></table></figure>
<h3 id="动态信号"><a href="#动态信号" class="headerlink" title="动态信号"></a>动态信号</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal5 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    [subscriber sendNext:@<span class="number">1</span>];</div><div class="line">    [subscriber sendNext:@<span class="number">2</span>];</div><div class="line">    [subscriber sendError:errorObject];</div><div class="line">    [subscriber sendCompleted];</div><div class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line">    &#125;];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="Cocoa桥接"><a href="#Cocoa桥接" class="headerlink" title="Cocoa桥接"></a>Cocoa桥接</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal6 = [view rac_signalForSelector:<span class="keyword">@selector</span>(setFrame:)];</div><div class="line">RACSignal *signal7 = [view rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">RACSignal *signal8 = [view rac_willDeallocSignal];</div><div class="line">RACSignal *signal9 = RACObserve(view, backgroundColor);</div></pre></td></tr></table></figure>
<h3 id="信号变换"><a href="#信号变换" class="headerlink" title="信号变换"></a>信号变换</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal10 = [signal1 map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *value) &#123;</div><div class="line">    <span class="keyword">return</span> [value substringFromIndex:<span class="number">1</span>];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="序列转换"><a href="#序列转换" class="headerlink" title="序列转换"></a>序列转换</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal11 = sequence.signal;</div></pre></td></tr></table></figure>
<h2 id="信号订阅过程举例"><a href="#信号订阅过程举例" class="headerlink" title="信号订阅过程举例"></a>信号订阅过程举例</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    [subscriber sendNext:@<span class="number">1</span>];</div><div class="line">    [subscriber sendNext:@<span class="number">2</span>];</div><div class="line">    [subscriber sendCompleted];</div><div class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"dispose"</span>);</div><div class="line">    &#125;];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"next value is %@"</span>, x);</div><div class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Ops! Get some error: %@"</span>, error);</div><div class="line">&#125; completed:^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"It finished success"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[disposable dispose];</div></pre></td></tr></table></figure>
<h2 id="RACSignal使用方法"><a href="#RACSignal使用方法" class="headerlink" title="RACSignal使用方法"></a>RACSignal使用方法</h2><h3 id="RACTuple-——-元组"><a href="#RACTuple-——-元组" class="headerlink" title="RACTuple —— 元组"></a>RACTuple —— 元组</h3><ul>
<li>RAC定义的一种数据类型</li>
<li>NSArray的简化版</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RACTuple *tuple = RACTuplePack(@<span class="number">1</span>, <span class="string">@"haha"</span>);</div><div class="line"><span class="keyword">id</span> first = tuple.first;</div><div class="line"><span class="keyword">id</span> second = tuple.second;</div><div class="line"><span class="keyword">id</span> last = tuple.last;</div><div class="line"><span class="keyword">id</span> index1 = tuple[<span class="number">1</span>];</div><div class="line">RACTupleUnpack(<span class="built_in">NSNumber</span> *num, <span class="built_in">NSString</span> *str) = tuple;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/RAC/">RAC</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/24/2016_08_25_ReactiveCocoaNote/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/24/2016_08_25_ReactiveCocoaNote/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/20/2015_08_20_DelegateForDatapass/" title="用委托在视图间传递消息的经典范例" itemprop="url">用委托在视图间传递消息的经典范例</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-08-20T06:50:28.000Z" itemprop="datePublished"> 发表于 2016-08-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>iOS中视图间数据传递的方式常有的有如下几种：</p>
<ol>
<li>采用代理模式</li>
<li>采用iOS消息机制</li>
<li>使用文件，NSUserdefault或者数据库来传递</li>
<li>通过AppDelegate定义全局变量（或者使用UIApplication、定义一个单例类等）</li>
<li>通过控制器属性传递</li>
</ol>
<p>今天我们主要采用第一种方式进行数据传递，这在iOS开发中也是最常见的一种多视图传参方式。使用代理方式传递参数的步骤如下：</p>
<ol>
<li>定义协议，协议中定义好传参时所需要的方法</li>
<li>目标视图控制器定义一个代理对象</li>
<li>源视图控制器实现协议，并在初始化目标控制器时指定目标控制器的代理为其自身</li>
<li>需要传参的时候在目标窗口调用代理的协议方法</li>
</ol>
<p>本例的操作如下所示：<br>一个界面为主视图，点击绿色的Button会Modal出第二个视图，在第二个视图的文本框里输入数据，并点击绿色的Button，会返回到主视图，并且把在第二个视图中输入的数据显示到主视图的文本框里，从而实现了参数跨视图传递；</p>
<p><img src="/images/2015_08_20_DelegateForDatapass1.png" width="32%">  <img src="/images/2015_08_20_DelegateForDatapass2.png" width="32%">  <img src="/images/2015_08_20_DelegateForDatapass3.png" width="32%"><br><!--![图片1](/images/2015_08_20_DelegateForDatapass1.png)
![图片2](/images/2015_08_20_DelegateForDatapass2.png =240x426)
![图片3](/images/2015_08_20_DelegateForDatapass3.png =240x426)--></p>
<p>整个程序的文件组织形式如下图所示：<br><img src="/images/2015_08_20_DelegateForDatapass4.png" width="33%"><br><!--![图片4](/images/2015_08_20_DelegateForDatapass4.png =260x374)--></p>
<h2 id="定义协议，协议中定义好传参时所需要的方法"><a href="#定义协议，协议中定义好传参时所需要的方法" class="headerlink" title="定义协议，协议中定义好传参时所需要的方法"></a>定义协议，协议中定义好传参时所需要的方法</h2><p>其中定义协议的文件为：<code>UIViewPassValueDelegate.h</code>。</p>
<p><strong>UIViewPassValueDelegate.h</strong>的源代码为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewPassValueDelegate</span></span></div><div class="line"></div><div class="line"><span class="comment">// 本方法为传参时所需要的方法</span></div><div class="line">- (<span class="keyword">void</span>)passValue:(<span class="built_in">NSString</span> *)value;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h2 id="源视图控制器实现协议，并在初始化目标控制器时指定目标控制器的代理为其自身"><a href="#源视图控制器实现协议，并在初始化目标控制器时指定目标控制器的代理为其自身" class="headerlink" title="源视图控制器实现协议，并在初始化目标控制器时指定目标控制器的代理为其自身"></a>源视图控制器实现协议，并在初始化目标控制器时指定目标控制器的代理为其自身</h2><p>源视图控制器就是这里的“主视图控制器”，在主视图控制器的实现文件中实现了该协议方法。其中主视图的相关文件为：<code>JJMainViewController.h</code>、<code>JJMainViewController.m</code>和<code>Main.storyboard</code>。</p>
<p>源代码分别为：</p>
<p><strong>JJMainViewController.h</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 导入协议文件的头文件</span></div><div class="line"><span class="meta">#import <span class="meta-string">"UIViewPassValueDelegate.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">// 遵守协议</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JJMainViewController</span> : <span class="title">UIViewController</span> &lt;<span class="title">UIViewPassValueDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 本属性为主界面上用来接收另一个视图传递过来的数据</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *valueField;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><strong>JJMainViewController.m</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"JJMainViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"JJAnotherViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JJMainViewController</span> </span></div><div class="line"></div><div class="line"><span class="comment">// 主视图遵守了委托协议，并实现了委托方法，本方法把另一个视图里的数据传递过来</span></div><div class="line">-(<span class="keyword">void</span>)passValue:(<span class="built_in">NSString</span> *)value &#123;</div><div class="line">    <span class="keyword">self</span>.valueField.text = value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)clickButton:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    </div><div class="line">    JJAnotherViewController *antherVC = [[JJAnotherViewController alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">// 把主视图设为另一个视图的委托对象</span></div><div class="line">    antherVC.delegate = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 点击了主视图的Button后Modal到另一个视图</span></div><div class="line">    [<span class="keyword">self</span> presentViewController:antherVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h2 id="目标视图控制器定义一个代理对象"><a href="#目标视图控制器定义一个代理对象" class="headerlink" title="目标视图控制器定义一个代理对象"></a>目标视图控制器定义一个代理对象</h2><p>这里的目标视图就是本例子中的“另一个视图”。另一个视图的文件为：<code>JJAnotherViewController.h</code>、<code>JJAnotherViewController.m</code>和<code>JJAnotherViewController.xib</code>。</p>
<p>源代码分别为：</p>
<p><strong>JJAnotherViewController.h</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"UIViewPassValueDelegate.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JJAnotherViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *value;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> &lt;<span class="built_in">UIViewPassValueDelegate</span>&gt; delegate;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><strong>JJAnotherViewController.m</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"JJAnotherViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JJAnotherViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)backButton:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 需要传参的时候在目标窗口调用代理的协议方法</span></div><div class="line">    [<span class="keyword">self</span>.delegate passValue:<span class="keyword">self</span>.value.text];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>综上，我们来重新将上述过程总结成大白话。为了能把目标视图里的数据通过委托协议传递给主视图，其过程如下：</p>
<ol>
<li>定义协议，协议中声明了一个方法，该方法用于把目标视图里的数据传递给源视图；</li>
<li>分别创建源视图和目标视图的控制器，并搭建好各自的界面；</li>
<li>在目标视图控制器的头文件里导入协议头文件，并定义一个用来存储待传递的数据的属性，和一个代理属性；</li>
<li>在目标视图控制器的实现文件里调用其代理属性的协议方法，并把待传的数据作为参数传入该方法；</li>
<li>让源视图控制器成为目标视图控制器的代理对象，从而源视图就可以接收来自目标视图的数据了，方法是：<ol>
<li>在源视图控制器的头文件里导入协议文件的头文件；</li>
<li>在源视图控制器的头文件里遵守协议，即用尖括号声明；</li>
<li>实现协议方法，在协议方法里接收来自目标视图的数据。参数由该协议方法的参数传递过来；</li>
</ol>
</li>
</ol>
<p>注：</p>
<ul>
<li><p>协议：本例中的<em>UIViewPassValueDelegate.h</em></p>
</li>
<li><p>协议方法：本例中的<em>- (void)passValue:(NSString \</em>)value*</p>
</li>
<li><p>源视图：本例中的<em>JJMainViewController</em></p>
</li>
<li><p>目标视图：本例中的<em>JJAnotherViewController</em></p>
</li>
<li><p>待传递的数据：本例中的目标视图里的文本框里输入的数据</p>
</li>
<li><p>为了防止循环引用代理属性的标识符应为assign，为了让各种对象都能成为本对象的代理对象其类型应为id</p>
</li>
</ul>
<h3 id="进一步抽取"><a href="#进一步抽取" class="headerlink" title="进一步抽取"></a>进一步抽取</h3><p><strong>关键步骤一：</strong>定义协议，协议中定义好可以用来传参的方法，本协议也可以直接定义到主视图控制器的.h文件里<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewPassValueDelegate</span></span></div><div class="line"></div><div class="line"><span class="comment">// 本方法为传参时所需要的方法</span></div><div class="line">- (<span class="keyword">void</span>)passValue:(<span class="built_in">NSString</span> *)value;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><strong>关键步骤二：</strong>在主视图控制器的.m文件中把本控制器的对象设为代理对象<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">JJAnotherViewController *antherVC = [[JJAnotherViewController alloc] init];</div><div class="line"></div><div class="line">antherVC.delegate = <span class="keyword">self</span>;</div></pre></td></tr></table></figure></p>
<p><strong>关键步骤三：</strong>同时，在主视图控制器的.m文件中实现协议方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)passValue:(<span class="built_in">NSString</span> *)value &#123;</div><div class="line">    <span class="keyword">self</span>.valueField.text = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>关键步骤四：</strong>在另一个视图控制器的.h文件中引入协议，并定义代理属性<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIViewPassValueDelegate.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> &lt;<span class="built_in">UIViewPassValueDelegate</span>&gt; delegate;</div><div class="line"></div><div class="line">若代理协议是在“主视图控制器”的.h文件中定义的，则本步骤的代码如下方式：</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewPassValueDelegate</span>;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="keyword">id</span>&lt;KCMainDelegate&gt; delegate;</div></pre></td></tr></table></figure></p>
<p><strong>关键步骤五：</strong>最后，在另一个视图控制器的.m文件中调用代理属性的协议方法传递参数</p>
<pre><code class="objc">[<span class="keyword">self</span>.delegate passValue:<span class="keyword">self</span>.value.text];
</code></pre>
<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><ol>
<li><p><a href="http://www.cnblogs.com/kenshincui/p/3940746.html#autoid-4-0-0" target="_blank" rel="external">iOS开发系列–视图切换</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/heri/archive/2013/03/18/2965815.html" target="_blank" rel="external">ios页面间传递参数四种方式</a>    </p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Delegate/">Delegate</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/20/2015_08_20_DelegateForDatapass/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/20/2015_08_20_DelegateForDatapass/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/12/2016_07_12_GitNote/" title="Git 学习笔记" itemprop="url">Git 学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-07-11T16:00:00.000Z" itemprop="datePublished"> 发表于 2016-07-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一张图读懂-Git"><a href="#一张图读懂-Git" class="headerlink" title="一张图读懂 Git"></a>一张图读懂 Git</h2><p><strong><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="external">工作区和暂存区的概念 – 廖雪峰</a></strong></p>
<p><img src="/images/2016071201_git_learn_note_00.png" alt="2016071201_git_learn_note_00"></p>
<h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><p><strong><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">Git远程操作详解 – 阮一峰</a></strong></p>
<ul>
<li><code>git clone &lt;git地址&gt;</code>：本地没有repository时，将远程repository整个下载过来。</li>
<li><code>git pull</code>：本地有repository，将远程repository里新的commit数据(如有的话)下载过来，并且与本地代码merge。</li>
<li><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>：用于将本地分支的更新，推送到远程主机。如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。eg：<code>git push origin master</code></li>
<li><code>git fetch</code>：将远程仓库的更新同步到本地</li>
<li><p><code>git pull</code>：取回远程仓库某个分支的更新，再与本地的指定分支合并</p>
</li>
<li><p>查看分支：<code>git branch</code></p>
</li>
<li>创建分支：<code>git branch &lt;name&gt;</code></li>
<li>切换分支：<code>git checkout &lt;name&gt;</code></li>
<li>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></li>
<li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li>
<li><p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
</li>
<li><p>创建一个与本地分支同名的远程分支：</p>
<p>  $ git push origin &lt;本地分支名&gt; </p>
</li>
</ul>
<p><strong><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单 – 阮一峰</a></strong></p>
<h2 id="分支的创建、合并、删除图示"><a href="#分支的创建、合并、删除图示" class="headerlink" title="分支的创建、合并、删除图示"></a>分支的创建、合并、删除图示</h2><p><strong><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="external">分支的创建、合并、删除图示 – 廖雪峰</a></strong></p>
<p>假设原来只有 master 分支 ↓ ：<br><img src="/images/2016071201_git_learn_note_01.png" alt="2016071201_git_learn_note_01"></p>
<p>创建一个叫 dev 的新分支，并切换到该分支上 ↓ ：<code>git checkout -b dev</code><br><img src="/images/2016071201_git_learn_note_02.png" alt="2016071201_git_learn_note_02"></p>
<p>在 dev 分支上进行一次提交 ↓ ：<code>git commit -m &quot;在dev分支上提交更改&quot;</code><br><img src="/images/2016071201_git_learn_note_03.png" alt="2016071201_git_learn_note_03"></p>
<p>把 dev 合并到 master 上 ↓ ：<code>git merge dev</code><br><img src="/images/2016071201_git_learn_note_04.png" alt="2016071201_git_learn_note_04"></p>
<p>删除 dev 分支 ↓ ：<code>git branch -d dev</code><br><img src="/images/2016071201_git_learn_note_05.png" alt="2016071201_git_learn_note_05"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>master：</code></strong>主分支；</li>
<li><strong><code>HEAD：</code></strong>始终指向当前分支；</li>
<li>Git 创建、合并、删除分支非常快，因为这些操作都是对指针的操作，改改 HEAD 的指向，工作区的文件都没有任何变化；</li>
<li>Git 鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在 master 分支上工作效果是一样的，但过程更安全。</li>
</ul>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><ul>
<li><strong>fork 按钮：</strong>fork 用于将他人的仓库复制到我们账号中。如果我们想要参与开源项目，首先要 fork 下别人的项目，然后在我们复制过来的仓库中，对别人的代码做修改。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Git/">Git</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Git/">Git</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/12/2016_07_12_GitNote/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/12/2016_07_12_GitNote/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/22/2015_08_22_OCFragmentary/" title="OC：零碎知识总结" itemprop="url">OC：零碎知识总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-22T13:55:07.000Z" itemprop="datePublished"> 发表于 2015-08-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="判断编译环境：ARC还是MRC？"><a href="#判断编译环境：ARC还是MRC？" class="headerlink" title="判断编译环境：ARC还是MRC？"></a>判断编译环境：ARC还是MRC？</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if __has_feature(objc_arc)</span></div><div class="line"><span class="comment">// 当前编译环境是ARC</span></div><div class="line"></div><div class="line"><span class="meta">#else</span></div><div class="line"><span class="comment">// 当前编译环境是MRC</span></div><div class="line"></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<h2 id="源码注释"><a href="#源码注释" class="headerlink" title="源码注释"></a>源码注释</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if __has_include(<span class="meta-string">&lt;JJObject.h&gt;</span>)</span></div><div class="line"></div><div class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JJObject</span> : <span class="title">NSObject</span></span></div><div class="line">...</div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name;</div><div class="line">...</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></div><div class="line"></div><div class="line"><span class="comment">// 禁止通过下面方式实例化对象</span></div><div class="line">- (<span class="keyword">instancetype</span>)new UNAVAILABLE_ATTRIBUTE</div></pre></td></tr></table></figure>
<p><code>__has_include</code> 用来检查 <code>Frameworks</code> 是否引入某个类</p>
<p>接口中 <code>nullable</code> 的是少数,一般都为 <code>nonnull</code>,为了防止写一大堆 <code>nonnull</code>，Foundation 供了一对宏<code>NS_ASSUME_NONNULL_BEGIN</code>、<code>NS_ASSUME_NONNULL_END</code>，包在里面的对象默认加 <code>nonnull</code> 修饰符，如果是<code>nullable</code> 的,只需要把 <code>nullable</code> 的指出来就行</p>
<p><code>UNAVAILABLE_ATTRIBUTE</code> 的宏定义为 <code>#define UNAVAILABLE_ATTRIBUTE __attribute__((unavailable))</code>, <code>__attribute__</code> 是 <code>Clang</code> 提供的一种源码注解，是GNU C特色之一，方便开发者向编译器表达某种要求，括号里是传达某种命令（format、deprecated、availability、unavailable、const、cleanup、constructor、destructor、noreturn、nonnull、aligned、packed）。为方便使用，一些常用属性也被 Cocoa 定义成宏，比如 <code>UNAVAILABLE_ATTRIBUTE</code>、<code>NS_CLASS_AVAILABLE_IOS(9_0)</code>。<br><code>unavailable</code> 告诉编译器该方法失效，在封装单例或初始化某个类前必须做一些事时，对一些方法禁用是非常不错的选择。还可以给个信息提示:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)new __attribute__((unavailable(<span class="string">"new方法不可用，请用initWithName:"</span>)));</div></pre></td></tr></table></figure></p>
<p>本文参考了 <a href="http://www.jianshu.com/p/b8dcf6634fab" target="_blank" rel="external">YYCache源码分析(一)</a> 和 <a href="http://www.jianshu.com/p/6153eccdbe62" target="_blank" rel="external">神奇的<strong>attribute</strong></a>。</p>
<h2 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h2><p>虽然 <code>#pragma</code> 最初的目的是为了使得源代码在不同的编译器下能够兼容，但精明的 Xcode 编码器将 <code>#pragma</code> 使用到了极致。<code>#pragma</code> 避开了<strong>注释</strong>和<strong>代码</strong>之间的界限。作为预处理指令，<code>#pragma</code> 在编译时进行计算。但它并不像如 <code>#ifdef...#endif</code> 之类的宏，<code>#pragma</code> 的使用方式不会改变应用运行时的行为。相反，<code>#pragma</code> 声明主要由 Xcode 用来完成两个主要任务：<strong>整理代码</strong>和<strong>防止编译器警告</strong>。</p>
<ul>
<li><p>在 <code>@implementation</code> 中使用 <code>#pragma mark</code> 来将代码分割成逻辑区块。<br><code>#pragma mark - &lt;代码段的名字&gt;</code>，如 #pragma mark - UITableViewDelegate</p>
</li>
<li><p>用 <code>#pragma</code> 声明来防止来自编译器或者静态分析器的警告。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// completionBlock在AFURLConnectionOperation中被手动的设置为nil来打破循环引用</span></div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-retain-cycles"</span></span></div><div class="line">    <span class="keyword">self</span>.completionBlock = ^ &#123;</div><div class="line">        ...</div><div class="line">    &#125;;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>通过使用 <code>#pragma clang diagnostic push/pop</code>，可以告诉编译器仅仅为某一特定部分的代码（最初的诊断设置在最后的 <code>pop</code> 被恢复）来忽视特定警告。</p>
<p>参考 <a href="http://clang.llvm.org/docs/UsersManual.html#diagnostics_pragmas" target="_blank" rel="external">Clang Compiler User’s Manual</a> 和 <a href="http://nshipster.cn/pragma/" target="_blank" rel="external">#pragma</a></p>
<h2 id="UIView、UIWindow、CALayer"><a href="#UIView、UIWindow、CALayer" class="headerlink" title="UIView、UIWindow、CALayer"></a>UIView、UIWindow、CALayer</h2><ol>
<li>UIView：<ul>
<li>属于<code>UIKit.framework</code>框架；</li>
<li>负责显示内容；</li>
<li>可以响应触摸事件；</li>
</ul>
</li>
<li>UIWindow：<ul>
<li>属于<code>UIKit.framework</code>框架；</li>
<li>UIWindow是一种特殊的UIView，通常一个程序中只有一个UIWindow，但是可以手动创建多个UIWindow，并同时加到程序里面；</li>
<li>UIWindow主要有三个作用：<ul>
<li>作为容器，包含APP中所要显示的所有视图；</li>
<li>传递触摸消息到程序中的View和其他对象；</li>
<li>与UIViewController协同工作，方便完成设备方向旋转的支持；</li>
</ul>
</li>
</ul>
</li>
<li>CALayer：<ul>
<li>属于<code>QuartzCore.framework</code>框架；</li>
<li>负责绘制内容；</li>
<li>不能响应触摸事件；</li>
</ul>
</li>
</ol>
<h2 id="contentSize、contentInset、contentOffset"><a href="#contentSize、contentInset、contentOffset" class="headerlink" title="contentSize、contentInset、contentOffset"></a>contentSize、contentInset、contentOffset</h2><p>参考 <a href="https://segmentfault.com/a/1190000002914912" target="_blank" rel="external">contentSize，contentInset 和 contentOffset 的含义</a></p>
<h2 id="设置状态栏隐藏"><a href="#设置状态栏隐藏" class="headerlink" title="设置状态栏隐藏"></a>设置状态栏隐藏</h2><p>在程序的启动过程中隐藏状态栏，在info.plist文件中添加如下内容即可：</p>
<p><img src="/images/2015_08_22_OCFragmentary1.png" alt="图片"></p>
<p>在APP指定的控制器的视图上隐藏状态栏，在控制器添加如下方法即可：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)prefersStatusBarHidden &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="App-Icons苹果官方指南"><a href="#App-Icons苹果官方指南" class="headerlink" title="App Icons苹果官方指南"></a>App Icons苹果官方指南</h2><p><a href="https://developer.apple.com/library/ios/qa/qa1686/_index.html" target="_blank" rel="external">App Icons 苹果官方指南</a></p>
<h2 id="可变集合类属性赋值崩溃问题"><a href="#可变集合类属性赋值崩溃问题" class="headerlink" title="可变集合类属性赋值崩溃问题"></a>可变集合类属性赋值崩溃问题</h2><ol>
<li>如果设置了 <code>NSMutableArray *</code> 属性，且没有用懒加载，记得要创建对象。</li>
<li>如果设置了 <code>NSMutableArray *</code> 属性，且没有用懒加载，则该属性要用 strong 指示符，而不是 copy，否则在调用 addObject: 方法时会崩溃（具体现象参考 <a href="http://www.cnblogs.com/wlll/p/5147024.html" target="_blank" rel="external">NSMutableArray, NSMutableDictionary 的内存管问题</a>）。原因：copy 拷贝出来的是一个不可变数组，对它添加元素就会造成 crash。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Fragmentary/">Fragmentary</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/22/2015_08_22_OCFragmentary/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/22/2015_08_22_OCFragmentary/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_Multithreading/" title="多线程编程之 概述" itemprop="url">多线程编程之 概述</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T12:48:54.000Z" itemprop="datePublished"> 发表于 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p><strong>主线程：</strong>应用程序启动时，最先执行的线程，用来描绘用户界面、处理触摸屏幕的事件等；</p>
<h3 id="并发性和并行性"><a href="#并发性和并行性" class="headerlink" title="并发性和并行性"></a>并发性和并行性</h3><p><strong>并行性（parallel）：</strong>同一时刻，有多条指令在多个处理器上同时执行；</p>
<p><strong>并发性（concurrency）：</strong>同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果；</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Multithreading/">Multithreading</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/17/2015_08_17_Multithreading/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/17/2015_08_17_Multithreading/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_GCD/" title="多线程编程之 GCD" itemprop="url">多线程编程之 GCD</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T12:27:35.000Z" itemprop="datePublished"> 发表于 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="GCD-中两个核心概念"><a href="#GCD-中两个核心概念" class="headerlink" title="GCD 中两个核心概念"></a>GCD 中两个核心概念</h2><ul>
<li><p><strong>队列：</strong>队列负责管理开发者提交的任务，队列始终以 FIFO（先进先出）的方式来处理任务，但由于任务的执行时间并不相同，因此处理的任务并不一定先结束。队列底层会维护一个线程池来处理用户提交的任务，线程池的作用就是<strong>执行</strong>队列管理的任务。</p>
</li>
<li><p><strong>任务：</strong>任务就是开发者提交给队列的<strong>工作单元</strong>，这些任务将会提交给队列底层维护的线程池执行。</p>
</li>
</ul>
<h2 id="GCD-中其它概念"><a href="#GCD-中其它概念" class="headerlink" title="GCD 中其它概念"></a>GCD 中其它概念</h2><p><strong>Dispatch Queue：</strong>执行处理的等待队列，按照追加的顺序（FIFO）执行处理。Dispatch Queue 分为 Serial Dispatch Queue 和 Concurrent Dispatch Queue；在不能改变执行的处理顺序或不想并发执行多个处理时使用 Serial Dispatch Queue。</p>
<p><strong>并行性（parallel）：</strong>同一时刻，有多条指令在多个处理器上同时执行；</p>
<p><strong>并发性（concurrency）：</strong>同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果；</p>
<p><strong>主线程：</strong>应用程序启动时，最先执行的线程，用来描绘用户界面、处理触摸屏幕的事件等。追加到主线程的处理在主线程的 RunLoop 中执行；</p>
<p>如果过多使用多线程，就会消耗大量内存，引起大量上下文切换，大幅度降低系统的响应性能；</p>
<h2 id="GCD-多线程编程的步骤"><a href="#GCD-多线程编程的步骤" class="headerlink" title="GCD 多线程编程的步骤"></a>GCD 多线程编程的步骤</h2><ul>
<li><p>创建队列；</p>
</li>
<li><p>创建任务，并将任务提交给队列；</p>
</li>
</ul>
<h2 id="Serial-Dispatch-Queue-和-Concurrent-Dispatch-Queue"><a href="#Serial-Dispatch-Queue-和-Concurrent-Dispatch-Queue" class="headerlink" title="Serial Dispatch Queue 和 Concurrent Dispatch Queue"></a>Serial Dispatch Queue 和 Concurrent Dispatch Queue</h2><p>当生成多个 Serial Dispatch Queue 时，各个 Serial Dispatch Queue 将并行执行。虽然在一个 Serial Dispatch Queue 中同时只能执行一个追加处理，但如果将10个处理分别追加到10个 Serial Dispatch Queue 中后，各个 Serial Dispatch Queue 执行一个追加处理，则能并发执行10个处理。</p>
<p>多个 Serial Dispatch Queue 同时执行会引发数据竞争问题。</p>
<p>当想并发执行又不发生数据竞争等问题的处理时，使用 Concurrent Dispatch Queue。</p>
<h2 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h2><pre><code>dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
</code></pre><p><strong>第一个参数const char *label：</strong>指定队列的名称，该名称推荐使用逆序全程域名（FQDN，fully qualified domain name）例如<code>com.example.gcd.MyConcurrentDispatchQueue</code>。该名称在 Xcode 和 Instruments 的调试器中作为 Dispatch Queue 名称表示。另外该名称也出现在应用程序崩溃时所生成的CrashLog中。</p>
<p><strong>第二个参数dispatch_queue_attr_t attr：</strong>指定队列的类型，即 Serial Dispatch Queue 或 Concurrent Dispatch Queue。当参数为NULL时为串行队列，当参数为DISPATCH_QUEUE_CONCURRENT时为并发队列。</p>
<pre><code>// 创建一个 Serial Dispatch Queue
dispatch_queue_t mySDQ = dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue&quot;, NULL);

// 创建一个 Concurrent Dispatch Queue
dispatch_queue_t myCDQ = dispatch_queue_create(&quot;com.example.gcd.MyConcurrentDispatchQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
</code></pre><p>ARC机制下不需要调用<code>void dispatch_release(dispatch_object_t object);</code>方法进行手动释放；    </p>
<h2 id="Main-Dispatch-Queue-和-Global-Dispatch-Queue"><a href="#Main-Dispatch-Queue-和-Global-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue 和 Global Dispatch Queue"></a>Main Dispatch Queue 和 Global Dispatch Queue</h2><p>Main Dispatch Queue 和 Global Dispatch Queue 是系统标准提供的 Dispatch Queue。</p>
<h3 id="Main-Dispatch-Queue"><a href="#Main-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue"></a>Main Dispatch Queue</h3><p><strong>Main Dispatch Queue：</strong>在主线程中执行的 Dispatch Queue，本质上是 Serial Dispatch Queue，追加到 Main Dispatch Queue 的处理在主线程的 RunLoop 中执行；</p>
<h5 id="dispatch-get-main-queue-方法"><a href="#dispatch-get-main-queue-方法" class="headerlink" title="dispatch_get_main_queue 方法"></a>dispatch_get_main_queue 方法</h5><pre><code>dispatch_queue_t dispatch_get_main_queue(void)
{
    return DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q);
}

其中

#define DISPATCH_GLOBAL_OBJECT(type, object) ((OS_OBJECT_BRIDGE type)&amp;(object))

#define OS_OBJECT_BRIDGE __bridge

struct dispatch_queue_s _dispatch_main_q;

也就是

dispatch_queue_t dispatch_get_main_queue(void)
{
    return (__bridge dispatch_queue_t) &amp; _dispatch_main_q;
}
</code></pre><p>举例：</p>
<pre><code>dispatch_queue_t mainDQ = dispatch_get_main_queue();
</code></pre><h3 id="Global-Dispatch-Queue"><a href="#Global-Dispatch-Queue" class="headerlink" title="Global Dispatch Queue"></a>Global Dispatch Queue</h3><p><strong>Global Dispatch Queue：</strong>是所有应用程序都能够使用的 Concurrent Dispatch Queue。没有必要通过 dispatch_queue_create 逐个生成 Concurrent Dispatch Queue，只要获取 Global Dispatch Queue 使用即可；</p>
<h5 id="dispatch-get-global-queue-方法"><a href="#dispatch-get-global-queue-方法" class="headerlink" title="dispatch_get_global_queue 方法"></a>dispatch_get_global_queue 方法</h5><pre><code>dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);
</code></pre><p>第二个参数 unsigned long flags：额外的旗标参数，暂未使用，只是为将来准备的，一般传入0即可；</p>
<h5 id="Global-Dispatch-Queue-有4个执行优先级"><a href="#Global-Dispatch-Queue-有4个执行优先级" class="headerlink" title="Global Dispatch Queue 有4个执行优先级"></a>Global Dispatch Queue 有4个执行优先级</h5><pre><code>DISPATCH_QUEUE_PRIORITY_HIGH 2
DISPATCH_QUEUE_PRIORITY_DEFAULT 0
DISPATCH_QUEUE_PRIORITY_LOW (-2)
DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN
</code></pre><p>举例：</p>
<pre><code>dispatch_queue_t globalDQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</code></pre><h2 id="dispatch-asyc-和-dispatch-syc"><a href="#dispatch-asyc-和-dispatch-syc" class="headerlink" title="dispatch_asyc 和 dispatch_syc"></a>dispatch_asyc 和 dispatch_syc</h2><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p>将处理在指定时间追加到 Dispatch Queue。经常和dispatch_time一起使用：</p>
<h4 id="dispatch-time"><a href="#dispatch-time" class="headerlink" title="dispatch_time"></a>dispatch_time</h4><pre><code>dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);
</code></pre><p>第一个参数 dispatch_time_t when：用来指定开始时间，经常用的参数是<code>DISPATCH_TIME_NOW</code>和<code>DISPATCH_TIME_FOREVER</code>；</p>
<pre><code>typedef uint64_t dispatch_time_t;

#define DISPATCH_TIME_NOW (0ull)
#define DISPATCH_TIME_FOREVER (~0ull)
</code></pre><p>第二个参数 int64_t delta：用来指定偏移时长，单位为纳秒，比如<code>3ull * NSEC_PER_SEC</code>表示<code>3 * 1000000000纳秒 = 3秒</code>；</p>
<pre><code>typedef    long long  int64_t;

#define NSEC_PER_SEC  1000000000ull  // 10的9次方，纳秒是10的-9次方
#define NSEC_PER_MSEC 1000000ull
#define USEC_PER_SEC  1000000ull
#define NSEC_PER_USEC 1000ull
</code></pre><p>其中数字后面的后缀ull表示unsigned long long；</p>
<h4 id="dispatch-after-1"><a href="#dispatch-after-1" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><pre><code>void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);
</code></pre><p>举例，在 3 秒后把某个指定的 Block 追加到 Main Dispatch Queue 中：</p>
<pre><code>dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);

dispatch_after(time, dispatch_get_main_queue(), ^{
    NSLog(@&quot;3秒后把本操作追加到 Main Dispatch Queue 中执行&quot;);
});
</code></pre><p>也可以将 dispatch_time 和 dispatch_after 两个方法合并起来用，这也是比较常用的方式：</p>
<pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3ull * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    NSLog(@&quot;3秒后把本操作追加到 Main Dispatch Queue 中执行&quot;);
});  
</code></pre><h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h2><p>用来变更 Dispatch Queue 的执行优先级（或执行层次）。</p>
<pre><code>void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);
</code></pre><p>第一个参数 dispatch_object_t object：被改变对象；</p>
<p>第二个参数 dispatch_queue_t queue：（目标）参考优先级。</p>
<p>将 dispatch_object_t object 的优先级改为与 dispatch_queue_t queue 的优先级相同；</p>
<p>举例：</p>
<pre><code>dispatch_queue_t mySDQ = dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue&quot;, NULL);

dispatch_queue_t myGDQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);

dispatch_set_target_queue(mySDQ, myGDQ);
</code></pre><p><strong>使用场景举例：</strong></p>
<p>有几个不可并发执行的处理，但是因为某种原因必须追加到多个 Serial Dispatch Queue 中时，会产生不可预期的后果，但是如果用dispatch_set_target_queue函数将目标指定为某一个 Serial Dispatch Queue，即可防止处理并发执行。但目前为止尚未遇到过这种情况。</p>
<h2 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h2><h2 id="dispatch-barrier-asyc"><a href="#dispatch-barrier-asyc" class="headerlink" title="dispatch_barrier_asyc"></a>dispatch_barrier_asyc</h2><h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><h2 id="dispatch-suspend-和-dispatch-resume"><a href="#dispatch-suspend-和-dispatch-resume" class="headerlink" title="dispatch_suspend 和 dispatch_resume"></a>dispatch_suspend 和 dispatch_resume</h2><h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h2><p>dispatch_once 函数的作用是在整个应用程序的生命周期中只执行一次代码块，而且是线程同步的，即不需要再使用@synchronized 之类的语句。</p>
<h2 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h2><h2 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h2>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/GCD/">GCD</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/17/2015_08_17_GCD/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/17/2015_08_17_GCD/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_NSOperation/" title="多线程编程之 NSOperation" itemprop="url">多线程编程之 NSOperation</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T07:31:01.000Z" itemprop="datePublished"> 发表于 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong>NSOperationQueue：</strong></p>
<p>NSOperationQueue 代表一个 FIFO 队列，它负责管理、执行添加的多个 NSOperation。NSOperationQueue底层维护了一个线程池，它会按顺序启动线程来执行提交给该队列的NSOperation任务。</p>
<p><strong>NSOperation：</strong></p>
<p>NSOperation 代表一个多线程任务，每个 NSOperation 中又可以封装多个待执行的操作。</p>
<p><strong>使用NSOperation与NSOperationQueue实现多线程编程的步骤：</strong></p>
<p>步骤一：先创建一个 NSOperationQueue 队列（主队列或非主队列）；</p>
<p>步骤二：创建一个 NSOperation 子类的对象，把需要执行的操作封装到 NSOperation 中；</p>
<p>步骤三：把封装后的 NSOperation 添加到 NSOperationQueue 队列中；</p>
<p>接下来系统会自动地将 NSOperationQueue 队列中的 NSOperation 取出，把封装到 NSOperation 中的操作放到线程里去执行；</p>
<h2 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h2><h3 id="有两种-NSOperationQueue-队列类型："><a href="#有两种-NSOperationQueue-队列类型：" class="headerlink" title="有两种 NSOperationQueue 队列类型："></a>有两种 NSOperationQueue 队列类型：</h3><p><strong>1&gt; 主队列</strong></p>
<pre><code>NSOperationQueue *queue = [NSOperationQueue mainQueue];
</code></pre><p>添加到主队列中的操作，都会放到主线程中执行，调用的是类方法<code>+ (NSOperationQueue *)mainQueue;</code></p>
<p><strong>2&gt; 非主队列</strong></p>
<pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];
</code></pre><p>添加到非主队列中的操作，都会开辟新线程异步并发执行</p>
<h3 id="往队列里添加任务的三种方式："><a href="#往队列里添加任务的三种方式：" class="headerlink" title="往队列里添加任务的三种方式："></a>往队列里添加任务的三种方式：</h3><pre><code>// 将 NSOperation 添加到队列中
-(void)addOperation:(NSOperation *)op;

// 将 Block 添加到队列中
-(void)addOperationWithBlock:(void (^)(void))block;

// 将 NSArray 中所有的 NSOperation 添加到队列中
// wait 为 YES，将会阻塞当前线程，直到提交的所有的 NSOperation 执行完成
// wait 为 NO，该方法会立即返回，NSArray 中包含的所有 NSOperation 将以异步方式执行，不会阻塞当前线程
-(void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait;
</code></pre><p>举例：</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;---下载1---%@&quot;, [NSThread currentThread]);
    }];

    NSInvocationOperation *operation2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download:) object:@&quot;下载&quot;];

    [queue addOperation:operation1];
    [queue addOperation:operation2];

    [queue addOperationWithBlock:^{
        NSLog(@&quot;---下载3---%@&quot;, [NSThread currentThread]);
    }];

}

- (void)download:(NSString *)string
{
    NSLog(@&quot;---%@2---%@&quot;,string ,[NSThread currentThread]);
}


输出如下：

2015-08-17 18:57:43.698 SingleViewAPPTest[3951:1080191] ---下载1---&lt;NSThread: 0x7ff669204140&gt;{number = 2, name = (null)}
2015-08-17 18:57:43.698 SingleViewAPPTest[3951:1080192] ---下载3---&lt;NSThread: 0x7ff668c2c010&gt;{number = 3, name = (null)}
2015-08-17 18:57:43.698 SingleViewAPPTest[3951:1080190] ---下载2---&lt;NSThread: 0x7ff668c2c290&gt;{number = 4, name = (null)}
</code></pre><h3 id="NSOperationQueue-的其它方法"><a href="#NSOperationQueue-的其它方法" class="headerlink" title="NSOperationQueue 的其它方法"></a>NSOperationQueue 的其它方法</h3><h4 id="最大并发数"><a href="#最大并发数" class="headerlink" title="最大并发数"></a>最大并发数</h4><pre><code>// 返回该 NSOperationQueue 队列支持的最大并发数量，即最大支持多少个并发线程
- (NSInteger)maxConcurrentOperationCount;

// 设置该 NSOperationQueue 队列支持的最大并发数量，即最大支持多少个并发线程
- (void)setMaxConcurrentOperationCount:(NSInteger)count;
</code></pre><p><code>maxConcurrentOperationCount</code>和<code>setMaxConcurrentOperationCount:</code>其实就是<code>maxConcurrentOperationCount</code>属性的getter、setter方法——专门用来控制 NSOperationQueue 所支持的最大并发数量。</p>
<h4 id="取消队列"><a href="#取消队列" class="headerlink" title="取消队列"></a>取消队列</h4><p>本方法用于取消 NSOperationQueue 队列中所有正在排队和执行的 NSOperation，是不可恢复。一般当有内存警告时用于取消所有任务。而NSOperation 的 cancel方法用于取消单个 operation。</p>
<pre><code>- (void)cancelAllOperations;
</code></pre><h4 id="暂停任务"><a href="#暂停任务" class="headerlink" title="暂停任务"></a>暂停任务</h4><pre><code>// 判断 NSOperationQueue 是否已暂停调度正在排队的 NSOperation
- (BOOL)isSuspended;

// 设置 NSOperationQueue 是否暂停调度正在排队的 NSOperation
// 当前后台切换或滚动操作时使用，用来暂停和恢复队列
- (void)setSuspended:(BOOL)suspend;
</code></pre><p>同样的，<code>isSuspended</code>和<code>setSuspended:</code>方法也是<code>suspended</code>属性的getter、setter方法。</p>
<h4 id="返回当前的队列"><a href="#返回当前的队列" class="headerlink" title="返回当前的队列"></a>返回当前的队列</h4><pre><code>// 返回执行当前 NSOperation 的 NSOperationQueue 队列
+ (NSOperationQueue *)currentQueue;
</code></pre><h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><pre><code>// 阻塞当前线程，直到该 NSOperationQueue 中所有排队和执行的 NSOperation 执行完成才接触阻塞
- (void)waitUntilAllOperationsAreFinished;
</code></pre><h3 id="NSOperationQueue-的属性"><a href="#NSOperationQueue-的属性" class="headerlink" title="NSOperationQueue 的属性"></a>NSOperationQueue 的属性</h3><pre><code>@property (readonly, copy) NSArray *operations;

@property (readonly) NSUInteger operationCount;

@property NSInteger maxConcurrentOperationCount;

@property (getter=isSuspended) BOOL suspended;

@property (copy) NSString *name;

@property NSQualityOfService qualityOfService;

@property (assign) dispatch_queue_t underlyingQueue;  /* assing actually retain */
</code></pre><h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p>NSOperation 是一个抽象类，并不具备封装操作的能力，必须使用它的子类。NSOperation 有两种使用方式：</p>
<p>1&gt; 直接使用子类 NSInvocationOperation 或者子类 NSBlockOperation；</p>
<p>2&gt; 开发者自己实现 NSOperation 子类；</p>
<h3 id="NSOperation-的方法"><a href="#NSOperation-的方法" class="headerlink" title="NSOperation 的方法"></a>NSOperation 的方法</h3><h4 id="开启操作"><a href="#开启操作" class="headerlink" title="开启操作"></a>开启操作</h4><pre><code>- (void)start;
</code></pre><p>只有一个 operation，这个 operation 又只有一个操作时，直接调用 start 方法，会在当前线程中同步执行；</p>
<p>只有一个 operation，但这个 operation 有多个操作时，这些操作会异步并发执行，而且其中的一个操作会在当前线程中执行；</p>
<pre><code>NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;---下载1---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载2---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载3---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载4---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载5---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载6---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载7---%@&quot;, [NSThread currentThread]);
}];

[operation start];

输出为：

2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960381] ---下载2---&lt;NSThread: 0x7fcfc3d1cdf0&gt;{number = 2, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960389] ---下载7---&lt;NSThread: 0x7fcfc502ad90&gt;{number = 5, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960382] ---下载1---&lt;NSThread: 0x7fcfc3e13360&gt;{number = 6, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960387] ---下载5---&lt;NSThread: 0x7fcfc3d248a0&gt;{number = 7, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960386] ---下载4---&lt;NSThread: 0x7fcfc5100590&gt;{number = 4, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960388] ---下载6---&lt;NSThread: 0x7fcfc3d207d0&gt;{number = 3, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960346] ---下载3---&lt;NSThread: 0x7fcfc3e0f900&gt;{number = 1, name = main}
</code></pre><p>结论1：这个 operation 必然会有一个操作是在当前线程中执行；</p>
<p>结论2：这个 operation 的所有操作都是并发执行的；</p>
<p>结论3：不会限制最大并发数，有多少个操作就开多少个线程（放到队列里默认也不限制最大并发数）；    </p>
<h4 id="取消操作"><a href="#取消操作" class="headerlink" title="取消操作"></a>取消操作</h4><pre><code>- (void)cancel;
</code></pre><h4 id="设置依赖"><a href="#设置依赖" class="headerlink" title="设置依赖"></a>设置依赖</h4><pre><code>// 设置 NSOperation 之间的依赖来保证执行顺序
// 例如[operationA addDependency:operationB]，给 operationA 添加了依赖
// 即 operationA 依赖于 operationB，只有等 operationB 执行完毕了才会执行 operationA
- (void)addDependency:(NSOperation *)op;

- (void)removeDependency:(NSOperation *)op;
</code></pre><ul>
<li><p>注意：不能相互依赖，比如 A 依赖 B，B 又依赖 A;</p>
</li>
<li><p>可以在不同的 NSOperationQueue 之间创建依赖关系;</p>
</li>
</ul>
<p>使用举例：</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];

    NSBlockOperation *operationA = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;---下载A---%@&quot;, [NSThread currentThread]);
    }];

    NSInvocationOperation *operationB = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download:) object:@&quot;B&quot;];


    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];

    NSBlockOperation *operationC = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;---下载C---%@&quot;, [NSThread currentThread]);
    }];

    [operationB addDependency:operationC];
    [operationA addDependency:operationB];

    [queue1 addOperation:operationA];
    [queue1 addOperation:operationB];
    [queue2 addOperation:operationC];

}

- (void)download:(NSString *)string
{
    NSLog(@&quot;---下载%@---%@&quot;,string ,[NSThread currentThread]);
}

@end

输出如下：

2015-08-17 19:10:53.235 SingleViewAPPTest[4139:1132032] ---下载C---&lt;NSThread: 0x7fbb69904e80&gt;{number = 2, name = (null)}
2015-08-17 19:10:53.235 SingleViewAPPTest[4139:1132032] ---下载B---&lt;NSThread: 0x7fbb69904e80&gt;{number = 2, name = (null)}
2015-08-17 19:10:53.236 SingleViewAPPTest[4139:1132032] ---下载A---&lt;NSThread: 0x7fbb69904e80&gt;{number = 2, name = (null)}
</code></pre><h4 id="等待执行完毕"><a href="#等待执行完毕" class="headerlink" title="等待执行完毕"></a>等待执行完毕</h4><pre><code>- (void ^(void))completionBlock;

// operation 的所有操作都执行完后立即开辟新线程来执行本方法的 Block 里的内容
// 本方法实际上是 (^completionBlock)(void) 属性的setter方法
- (void)setCompletionBlock:(void (^)(void)())block;
</code></pre><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><pre><code>- (void)main;

- (void)waitUntilFinished;
</code></pre><h3 id="NSOperation-的属性"><a href="#NSOperation-的属性" class="headerlink" title="NSOperation 的属性"></a>NSOperation 的属性</h3><pre><code>@property (readonly, getter=isCancelled) BOOL cancelled;

@property (readonly, getter=isExecuting) BOOL executing;

@property (readonly, getter=isFinished) BOOL finished;

@property (readonly, getter=isConcurrent) BOOL concurrent;

@property (readonly, getter=isAsynchronous) BOOL asynchronous;

@property (readonly, getter=isReady) BOOL ready;

@property (readonly, copy) NSArray *dependencies;

@property NSOperationQueuePriority queuePriority;

@property (copy) void (^completionBlock)(void);

@property double threadPriority;

@property NSQualityOfService qualityOfService;

@property (copy) NSString *name ;
</code></pre><h2 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h2><p>NSInvocationOperation 和 NSBlockOperation 都是 NSOperation 的子类，都可在程序中直接使用，用于封装需要异步执行的任务。NSInvocationOperation 用于将<strong>特定对象</strong>的<strong>特定方法</strong>封装成 NSOperation。</p>
<h3 id="NSInvocationOperation-的方法"><a href="#NSInvocationOperation-的方法" class="headerlink" title="NSInvocationOperation 的方法"></a>NSInvocationOperation 的方法</h3><pre><code>- (instancetype)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;

- (instancetype)initWithInvocation:(NSInvocation *)inv;
</code></pre><h3 id="NSInvocationOperation-的属性"><a href="#NSInvocationOperation-的属性" class="headerlink" title="NSInvocationOperation 的属性"></a>NSInvocationOperation 的属性</h3><pre><code>@property (readonly, retain) NSInvocation *invocation;

@property (readonly, retain) id result;
</code></pre><h2 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h2><h3 id="NSBlockOperation-的方法"><a href="#NSBlockOperation-的方法" class="headerlink" title="NSBlockOperation 的方法"></a>NSBlockOperation 的方法</h3><pre><code>+ (instancetype)blockOperationWithBlock:(void (^)(void))block;

- (void)addExecutionBlock:(void (^)(void))block;
</code></pre><h3 id="NSBlockOperation-的属性"><a href="#NSBlockOperation-的属性" class="headerlink" title="NSBlockOperation 的属性"></a>NSBlockOperation 的属性</h3><pre><code>@property (readonly, copy) NSArray *executionBlocks;
</code></pre><h2 id="自定义的-NSOperation-的子类"><a href="#自定义的-NSOperation-的子类" class="headerlink" title="自定义的 NSOperation 的子类"></a>自定义的 NSOperation 的子类</h2><p>除了使用已经提供的 NSOperation 的两个子类外，开发者也可以自定义NSOperation 的子类，但是本方法比较少用。具体步骤如下：</p>
<p>1&gt; 创建一个类，继承自 NSOperation；</p>
<p>2&gt; 重写<code>- (void)main</code>方法，在本方法里实现要执行的任务；</p>
<h2 id="回到主线程的三种方式"><a href="#回到主线程的三种方式" class="headerlink" title="回到主线程的三种方式"></a>回到主线程的三种方式</h2><h3 id="用performSelector-方法"><a href="#用performSelector-方法" class="headerlink" title="用performSelector 方法"></a>用performSelector 方法</h3><pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    [queue addOperationWithBlock:^{
        // 下载下载图片

        // 回到主线程
        [self performSelectorOnMainThread:@selector(download:) withObject:@&quot;已经回到主线程&quot; waitUntilDone:YES];

    }];
}

- (void)download:(NSString *)string
{
    NSLog(@&quot;%@&quot;, string);
}
</code></pre><h3 id="用GCD"><a href="#用GCD" class="headerlink" title="用GCD"></a>用GCD</h3><pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];

[queue addOperationWithBlock:^{
    // 下载下载图片

    // 回到主线程
    dispatch_async(dispatch_get_main_queue(), ^{
        // 回到主线程后执行的操作
    });

}];
</code></pre><h3 id="用-NSOperationQueue"><a href="#用-NSOperationQueue" class="headerlink" title="用 NSOperationQueue"></a>用 NSOperationQueue</h3><pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];

[queue addOperationWithBlock:^{
    // 下载下载图片

    // 回到主线程
    [[NSOperationQueue mainQueue] addOperationWithBlock:^{
        // 回到主线程后执行的操作
    }];

}];
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/NSOperation/">NSOperation</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/17/2015_08_17_NSOperation/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/17/2015_08_17_NSOperation/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_CFragmentary/" title="C 语言：零碎知识总结" itemprop="url">C 语言：零碎知识总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T02:48:28.000Z" itemprop="datePublished"> 发表于 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数。</p>
<pre><code>// 定义回调函数1
void PrintfText()
{
    printf(&quot;Hello World!\n&quot;);
}

// 定义回调函数2
void PrintfInt()
{
    printf(&quot;10\n&quot;);
}

// 定义实现回调函数的&quot;调用函数&quot;
void CallPrintf(void (*callfuct)(void))
{
    callfuct();
}

// 在main函数中实现函数回调
int main(int argc,char* argv[])
{
    CallPrintf(PrintfText);
    CallPrintf(PrintfInt);
    return 0;
}
</code></pre>
        
        
        <p class="article-more-link">
          
            <a href="/2015/08/17/2015_08_17_CFragmentary/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/17/2015_08_17_CFragmentary/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/17/2015_08_17_CFragmentary/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2015_08_16_NSStringIsEqual/" title="isEqual 和 == 的比较" itemprop="url">isEqual 和 == 的比较</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T11:45:53.000Z" itemprop="datePublished"> 发表于 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>== 和 isEqual 都是用来判断连个变量是否相等；</p>
<h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>1.<code>数值型</code>的基本类型变量比较：不一定要求数据类型严格相同，只要值相等，则返回真；</p>
<p>例如：<code>int型50 == float型50.0f；</code></p>
<p>2.<code>指针类型</code>变量比较：必须指向同一个对象，即两个指针变量保存的内存地址相同，返回真；</p>
<p>3.没有继承关系的两个指针变量比较：编译时提示警告；</p>
<h2 id="isEqual"><a href="#isEqual" class="headerlink" title="isEqual"></a>isEqual</h2><p>1.<code>指针类型</code>变量比较：同 ==，都是必须指向同一个对象，即两个指针变量保存的内存地址相同，返回真；</p>
<p>2.NSString 的 isEqual 方法：只要两个字符串包含相同的字符串序列，则返回真；</p>
<p>因为 isEqual 方法就指针类型变量的比较，本身与 == 没有区别，同时没有太大的意义，所以 NSString 重写了该方法，实现了值比较而不是地址比较。我们在编程时同样可以重写该方法来满足我们所要求的比较方式；</p>
<h2 id="字符型常量"><a href="#字符型常量" class="headerlink" title="字符型常量"></a>字符型常量</h2><p>像类似于<code>@&quot;hello&quot;</code>这种字符型常量是由常量池来存储管理的，常量池可以保证相同的字符串直接量只有一个；</p>
<p>而<code>[NSString stringWithFormat:@&quot;hello&quot;]</code>类型的字符串对象是运行时创建出来的，它被保存在运行时内存区（即堆内存），不会放入常量池中；</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/isEqual/">isEqual</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2015_08_16_NSStringIsEqual/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2015_08_16_NSStringIsEqual/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2015_08_16_NSString/" title="NSString 转换" itemprop="url">NSString 转换</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T11:12:14.000Z" itemprop="datePublished"> 发表于 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="其它-——-gt-NSString"><a href="#其它-——-gt-NSString" class="headerlink" title="其它 ——&gt; NSString"></a>其它 ——&gt; NSString</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSStringFromRange</span>( <span class="built_in">NSRange</span> range );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromRect</span>( <span class="built_in">NSRect</span> aRect );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromSelector</span>( SEL aSelector );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromClass</span>( __<span class="keyword">unsafe_unretained</span> Class aClass );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromProtocol</span>( Protocol *proto );</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSStringFromHashTable</span>( <span class="built_in">NSHashTable</span> *table );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromMapTable</span>( <span class="built_in">NSMapTable</span> *table );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromPoint</span>( <span class="built_in">NSPoint</span> aPoint );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromSize</span>( <span class="built_in">NSSize</span> aSize );</div></pre></td></tr></table></figure>
<p>举例：</p>
<pre><code>NSString *string = NSStringFromClass([NSArray class]);

NSLog(@&quot;NSArray 的类名是：%@&quot;,string);

输出如下：

2015-08-18 16:10:17.908 NewCommandTest[845:137450] NSArray 的类名是：NSArray
</code></pre><h2 id="NSNumber-——-gt-NSString"><a href="#NSNumber-——-gt-NSString" class="headerlink" title="NSNumber ——&gt; NSString"></a>NSNumber ——&gt; NSString</h2><pre><code>NSNumber *number = [NSNumber numberWithInt:20];

// 转换方法1
NSString *string = [number description];

// 转换方法2
NSString *string = [NSString stringWithFormat:@&quot;%d&quot;, [number intValue]];
</code></pre><p>本例是将<code>@20</code>转换为<code>@&quot;20&quot;</code>。</p>
<h2 id="NSData-——-gt-NSString"><a href="#NSData-——-gt-NSString" class="headerlink" title="NSData ——&gt; NSString"></a>NSData ——&gt; NSString</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.baidu.com"</span>]];</div><div class="line">       </div><div class="line"><span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
            <a href="/2015/08/16/2015_08_16_NSString/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C/">Objective-C</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/NSString/">NSString</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2015_08_16_NSString/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2015_08_16_NSString/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2016_09_22_Blocks/" title="Blosks 浅析" itemprop="url">Blosks 浅析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T07:28:30.000Z" itemprop="datePublished"> 发表于 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-Blocks概要"><a href="#1-Blocks概要" class="headerlink" title="1 Blocks概要"></a>1 Blocks概要</h2><p>带有自动变量（局部变量）的匿名函数（在标准的C和Objective-C语言中是不允许有匿名函数的）。</p>
<p>C语言中的变量类型：</p>
<p>1.自动变量Automatic variables（局部变量local variables）</p>
<p>2.静态变量Static variables（静态局部变量static local variables）</p>
<p>3.全局变量Global variables</p>
<p>4.静态全局变量Static global variables</p>
<p>5.函数的参数Function arguments</p>
<p>其中，在函数的多次调用之间能够传递值的变量有：</p>
<p>1.静态变量（静态局部变量）</p>
<p>2.静态全局变量</p>
<p>3.全局变量</p>
<h2 id="2-Blocks模式"><a href="#2-Blocks模式" class="headerlink" title="2 Blocks模式"></a>2 Blocks模式</h2><h3 id="2-1-Blocks语法"><a href="#2-1-Blocks语法" class="headerlink" title="2.1 Blocks语法"></a>2.1 Blocks语法</h3><p>完整形式的Block语法与C语言函数相比，仅有两点区别：</p>
<p>（1）没有函数名。</p>
<p>（2）带有插入记号“^”。</p>
<h4 id="完整形式的Block语法格式："><a href="#完整形式的Block语法格式：" class="headerlink" title="完整形式的Block语法格式："></a>完整形式的Block语法格式：</h4><pre><code>^ 返回值类型 参数列表 表达式
</code></pre><p>例如：    </p>
<pre><code>^int (int count) {return count + 1;}
</code></pre><h4 id="省略返回值类型的Block语法格式："><a href="#省略返回值类型的Block语法格式：" class="headerlink" title="省略返回值类型的Block语法格式："></a>省略返回值类型的Block语法格式：</h4><pre><code>^ 参数列表 表达式
</code></pre><h4 id="省略返回值类型时则Block的返回值类型为："><a href="#省略返回值类型时则Block的返回值类型为：" class="headerlink" title="省略返回值类型时则Block的返回值类型为："></a>省略返回值类型时则Block的返回值类型为：</h4><p>1.如果表达式没有return语句，则Block的返回值类型为void；</p>
<p>2.如果表达式有return语句，则Block的返回值类型就是return的类型；</p>
<p>3.如果表达式有多个return语句，则所有return的类型必须相同；</p>
<p>例如：</p>
<pre><code>^(int count) {return count + 1;}
</code></pre><h4 id="省略返回值类型和参数列表的Block语法格式："><a href="#省略返回值类型和参数列表的Block语法格式：" class="headerlink" title="省略返回值类型和参数列表的Block语法格式："></a>省略返回值类型和参数列表的Block语法格式：</h4><pre><code>^ 表达式
</code></pre><p>当不使用参数时，参数列表可以省略。</p>
<p>例如：</p>
<pre><code>^{printf(&quot;Blocks&quot;);}
</code></pre><h3 id="2-2-Block类型变量"><a href="#2-2-Block类型变量" class="headerlink" title="2.2 Block类型变量"></a>2.2 Block类型变量</h3><p>函数指针类型变量举例：    </p>
<pre><code>int func(int count)
{
    return count + 1;
}

int (*funcptr)(int) = &amp;func;

funcptr(5);
</code></pre><p>类似地，可将Block literal赋值给Block-type变量。When a Block literal is in source code, a value is generated. The value can be assigned to a variable of the Block type. In Blocks, the generated value is called Block as well. “Block”既指Block literal itself in a source code，也指the value generated from the Block literal.</p>
<p>Block类型变量举例：</p>
<pre><code>int (^blk)(int) = ^int (int count){return count + 1;};

blk(5);
</code></pre><p>注意，Block代码块不能像函数一样在外面定义，只能像一个表达式一样使用，比如定义完了立即赋给一个Block类型变量，或者作为函数的返回值。这里的Block就是生成的value。</p>
<p>Block类型变量与一般的C语言变量完全相同，都可以用作自动变量、静态变量、全局变量、静态全局变量、函数参数：</p>
<pre><code>1、将Block赋值给Block类型变量：

int (^blk)(int) = ^int (int count){return count + 1;};   

2、将Block类型变量赋值给Block类型变量：

int (^blk1)(int) = blk;

int (^blk2)(int);

blk2 = blk;

3、将Block类型变量作为函数参数来向函数传递Block：

void func(int (^blk)(int))

{
    // 执行代码...
}

4、将Block作为函数的返回值返回：

int (^func())(int)

{
    // 执行代码...
    return ^int (int count){return count + 1;};
}

5、也可以定义Block的指针类型变量：

typedef int (^blk_t)(int);

blk_t blk = ^int (int count){return count + 1;};

blk_t *blkptr = &amp;blk;

(*blkptr)(10);
</code></pre><h3 id="2-3-截获自动变量值和-block说明符"><a href="#2-3-截获自动变量值和-block说明符" class="headerlink" title="2.3 截获自动变量值和__block说明符"></a>2.3 截获自动变量值和__block说明符</h3><p>基本类型变量的截获：</p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    int val = 10; 

    void (^blk)(void) = ^{printf(&quot;%d\n&quot;, val);};   // 在这里截获自动变量val的值 

    blk();  // 输出10，注意不要写成blk;

    val = 2;

    blk();  // 输出也是10
}
</code></pre><p>Block语法使用了自动变量val的值，即Block语法保存了该自动变量的瞬间值，在执行完Block语法后，即使改写了Block中使用的自动变量的值也不会影响Block执行时的自动变量的值，称之为“截获自动变量的值”。</p>
<p>When automatic variables are captured, the values are read-only in the Block. 在上例的Block语法里尝试将val的值改为1时，会产生变异错误。</p>
<p>在自动变量前面加上__block说明符后，就可在Block里和Block外修改该自动变量的值而影响到Block。    </p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    __block int val = 10;

    void (^blk)(void) = ^{printf(&quot;%d\n&quot;, val);};   // 在这里截获自动变量val的值 

    blk();  // 输出10

    val = 2;

    blk();  // 输出2
}
</code></pre><p>以及：    </p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    __block int val = 10;

    void (^blk)(void) = ^{

        val = 1;

        printf(&quot;%d\n&quot;, val);

    };

    blk();  // 输出1

}
</code></pre><h4 id="对象类型变量的截获："><a href="#对象类型变量的截获：" class="headerlink" title="对象类型变量的截获："></a>对象类型变量的截获：</h4><pre><code>1、截获OC对象后，调用该对象的方法来修改该对象（使用截获的值），没有任何问题：

    id array = [[NSMutableArray alloc] init];

    void (^blk)(void) = ^{

        id obj = [[NSObject alloc] init];

            [array addObject:obj];  // 没有任何问题

    };       

2、截获OC对象后，向截获的对象变量赋值，则会产生编译错误：

    id array = [[NSMutableArray alloc] init];

    void (^blk)(void) = ^{

        array = [[NSMutableArray alloc] init]; // 产生编译错误

    };             

3、截获带有__block修饰符的OC对象，不管是使用该对象还是向该对象赋值，都没有任何问题：

       __block id array = [[NSMutableArray alloc] init];

           void (^blk)(void) = ^{

               array = [[NSMutableArray alloc] init]; // 没有任何问题

           };    

   4、由于Blocks支持截获C语言数组，所以在Block中需要用到数组时，要用指针代替数组操作：

       const char text[] = &quot;Hello&quot;;

       void (^blk)(void) = ^{

           printf(&quot;%c\n&quot;, text[2]); // 产生编译错误

       };

   改用指针来操作数组：

       const char *text = &quot;Hello&quot;;

       void (^blk)(void) = ^{

           printf(&quot;%c\n&quot;, text[2]); // 没有任何问题

       };
</code></pre><h2 id="3-Blocks的实现"><a href="#3-Blocks的实现" class="headerlink" title="3 Blocks的实现"></a>3 Blocks的实现</h2><h3 id="3-1-Block的本质"><a href="#3-1-Block的本质" class="headerlink" title="3.1 Block的本质"></a>3.1 Block的本质</h3><p>看似高大上的Block语法，实际上也是作为极普通的C语言源代码来处理的。通过clang（LLVM编译器）的“-rewrite-objc”选项，可以将含有Block语法的源代码转换为C++源代码（其实是使用了struct结构的C语言源代码）。    </p>
<pre><code>clang -rewrite-objc 源代码文件名
</code></pre><p>下例为一个最简单的Block的使用范例：</p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    void (^blk)(void) = ^{

        printf(&quot;Block&quot;);

    };

    blk();

    return 0;
}
</code></pre><p>将上述含有 Block 语法的源代码用<code>clang</code>转换为 C++ 源代码：</p>
<pre><code>struct __block_impl {

    void *isa;

    int Flags;

    int Reserved;

    void *FuncPtr;

};

struct __main_block_impl_0 {

    struct __block_impl impl;

    struct __main_block_desc_0* Desc;

    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {

    impl.isa = &amp;_NSConcreteStackBlock;

    impl.Flags = flags;

    impl.FuncPtr = fp;

    Desc = desc;

    }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

    printf(&quot;Block&quot;);

}

static struct __main_block_desc_0 {

    size_t reserved;

    size_t Block_size;

} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main()

{

    void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);

    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);

    return 0;

}
</code></pre><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><pre><code>void (^blk)(void) = ^{printf(&quot;Block&quot;);};
</code></pre><p>等价于：</p>
<pre><code>void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
</code></pre><p>分解为：</p>
<pre><code>void (*blk)(void) = (void (*)())&amp;tmp;

tmp = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
</code></pre><p>再分解：</p>
<pre><code>struct __main_block_impl_0 *blk = &amp;tmp;

struct __main_block_impl_0 tmp = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
</code></pre><h4 id="解读："><a href="#解读：" class="headerlink" title="解读："></a>解读：</h4><p>将由 Block literal 生成的 Block（value） 赋值给 Block 类型的变量<code>blk</code>；</p>
<p>即把栈上生成的<code>__main_block_impl_0</code>结构体的实例<code>tmp</code>的指针赋给变量<code>blk</code>；</p>
<p>我猜<code>^{printf(&quot;Block&quot;);}</code>就是所谓的<code>Block（value）</code>，该 Block 等价为<code>__main_block_impl_0</code>结构体类型的自动变量；换句话说，该 Block 就是<code>__main_block_impl_0</code>结构体在栈上生成的实例；</p>
<h4 id="综上分析得出结论："><a href="#综上分析得出结论：" class="headerlink" title="综上分析得出结论："></a>综上分析得出结论：</h4><p><code>void (^blk)(void) = ^{printf(&quot;Block&quot;);};</code>中的<code>^{printf(&quot;Block&quot;);}</code>为<code>__main_block_impl_0</code>结构体在栈上生成的实例；而<code>blk</code>为指向该实例的指针变量；</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Blosks/">Blosks</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2016_09_22_Blocks/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2016_09_22_Blocks/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2015_08_16_Octopress/" title="用 Octopress 搭建静态博客并发布文章" itemprop="url">用 Octopress 搭建静态博客并发布文章</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T05:51:41.000Z" itemprop="datePublished"> 发表于 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="克隆Octopress"><a href="#克隆Octopress" class="headerlink" title="克隆Octopress"></a>克隆Octopress</h3><p>从Github上将Octopress项目克隆到本地的Octopress目录下：</p>
<pre><code>git clone git://github.com/imathis/octopress.git Octopress
</code></pre><h3 id="进入Octopress项目根目录"><a href="#进入Octopress项目根目录" class="headerlink" title="进入Octopress项目根目录"></a>进入Octopress项目根目录</h3><pre><code>cd Octopress
</code></pre>
        
        
        <p class="article-more-link">
          
            <a href="/2015/08/16/2015_08_16_Octopress/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Blog/">Blog</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Octopress/">Octopress</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2015_08_16_Octopress/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2015_08_16_Octopress/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Blog/" title="Blog">Blog<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/C/" title="C">C<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Git/" title="Git">Git<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C/" title="Objective-C">Objective-C<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>19</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/RAC/" title="RAC">RAC<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/UIImage/" title="UIImage">UIImage<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/UINavigationController/" title="UINavigationController">UINavigationController<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Octopress/" title="Octopress">Octopress<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GCD/" title="GCD">GCD<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Multithreading/" title="Multithreading">Multithreading<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NSOperation/" title="NSOperation">NSOperation<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Fragmentary/" title="Fragmentary">Fragmentary<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Delegate/" title="Delegate">Delegate<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Git/" title="Git">Git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/isEqual/" title="isEqual">isEqual<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UIButton/" title="UIButton">UIButton<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Push/" title="Push">Push<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NSUserDefaults/" title="NSUserDefaults">NSUserDefaults<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Blosks/" title="Blosks">Blosks<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NSLog/" title="NSLog">NSLog<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Notifications/" title="Notifications">Notifications<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Animation/" title="Animation">Animation<sup>1</sup></a></li>
			
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Liu2er">Liu2er</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
