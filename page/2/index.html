
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Liu2er的技术博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Liu2er">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Liu2er的技术博客">
<meta property="og:url" content="http://liu2er.com/page/2/index.html">
<meta property="og:site_name" content="Liu2er的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liu2er的技术博客">

    
    <link rel="alternative" href="/atom.xml" title="Liu2er的技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Liu2er的技术博客">Liu2er的技术博客</a></h1>
				<h2 class="blog-motto">世界那么大，我早晚要去看</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:liu2er.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/20/2015_08_20_DelegateForDatapass/" title="用委托在视图间传递消息的经典范例" itemprop="url">用委托在视图间传递消息的经典范例</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-08-20T06:50:28.000Z" itemprop="datePublished"> Published 2016-08-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>iOS中视图间数据传递的方式常有的有如下几种：</p>
<ol>
<li>采用代理模式</li>
<li>采用iOS消息机制</li>
<li>使用文件，NSUserdefault或者数据库来传递</li>
<li>通过AppDelegate定义全局变量（或者使用UIApplication、定义一个单例类等）</li>
<li>通过控制器属性传递</li>
</ol>
<p>今天我们主要采用第一种方式进行数据传递，这在iOS开发中也是最常见的一种多视图传参方式。使用代理方式传递参数的步骤如下：</p>
<ol>
<li>定义协议，协议中定义好传参时所需要的方法</li>
<li>目标视图控制器定义一个代理对象</li>
<li>源视图控制器实现协议，并在初始化目标控制器时指定目标控制器的代理为其自身</li>
<li>需要传参的时候在目标窗口调用代理的协议方法</li>
</ol>
<p>本例的操作如下所示：<br>一个界面为主视图，点击绿色的Button会Modal出第二个视图，在第二个视图的文本框里输入数据，并点击绿色的Button，会返回到主视图，并且把在第二个视图中输入的数据显示到主视图的文本框里，从而实现了参数跨视图传递；</p>
<p><img src="/images/2015_08_20_DelegateForDatapass1.png" width="32%">  <img src="/images/2015_08_20_DelegateForDatapass2.png" width="32%">  <img src="/images/2015_08_20_DelegateForDatapass3.png" width="32%"><br><!--![图片1](/images/2015_08_20_DelegateForDatapass1.png)
![图片2](/images/2015_08_20_DelegateForDatapass2.png =240x426)
![图片3](/images/2015_08_20_DelegateForDatapass3.png =240x426)--></p>
<p>整个程序的文件组织形式如下图所示：<br><img src="/images/2015_08_20_DelegateForDatapass4.png" width="33%"><br><!--![图片4](/images/2015_08_20_DelegateForDatapass4.png =260x374)--></p>
<h2 id="定义协议，协议中定义好传参时所需要的方法"><a href="#定义协议，协议中定义好传参时所需要的方法" class="headerlink" title="定义协议，协议中定义好传参时所需要的方法"></a>定义协议，协议中定义好传参时所需要的方法</h2><p>其中定义协议的文件为：<code>UIViewPassValueDelegate.h</code>。</p>
<p><strong>UIViewPassValueDelegate.h</strong>的源代码为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewPassValueDelegate</span></span></div><div class="line"></div><div class="line"><span class="comment">// 本方法为传参时所需要的方法</span></div><div class="line">- (<span class="keyword">void</span>)passValue:(<span class="built_in">NSString</span> *)value;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h2 id="源视图控制器实现协议，并在初始化目标控制器时指定目标控制器的代理为其自身"><a href="#源视图控制器实现协议，并在初始化目标控制器时指定目标控制器的代理为其自身" class="headerlink" title="源视图控制器实现协议，并在初始化目标控制器时指定目标控制器的代理为其自身"></a>源视图控制器实现协议，并在初始化目标控制器时指定目标控制器的代理为其自身</h2><p>源视图控制器就是这里的“主视图控制器”，在主视图控制器的实现文件中实现了该协议方法。其中主视图的相关文件为：<code>JJMainViewController.h</code>、<code>JJMainViewController.m</code>和<code>Main.storyboard</code>。</p>
<p>源代码分别为：</p>
<p><strong>JJMainViewController.h</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 导入协议文件的头文件</span></div><div class="line"><span class="meta">#import <span class="meta-string">"UIViewPassValueDelegate.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">// 遵守协议</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JJMainViewController</span> : <span class="title">UIViewController</span> &lt;<span class="title">UIViewPassValueDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 本属性为主界面上用来接收另一个视图传递过来的数据</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *valueField;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><strong>JJMainViewController.m</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"JJMainViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"JJAnotherViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JJMainViewController</span> </span></div><div class="line"></div><div class="line"><span class="comment">// 主视图遵守了委托协议，并实现了委托方法，本方法把另一个视图里的数据传递过来</span></div><div class="line">-(<span class="keyword">void</span>)passValue:(<span class="built_in">NSString</span> *)value &#123;</div><div class="line">    <span class="keyword">self</span>.valueField.text = value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)clickButton:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    </div><div class="line">    JJAnotherViewController *antherVC = [[JJAnotherViewController alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">// 把主视图设为另一个视图的委托对象</span></div><div class="line">    antherVC.delegate = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 点击了主视图的Button后Modal到另一个视图</span></div><div class="line">    [<span class="keyword">self</span> presentViewController:antherVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h2 id="目标视图控制器定义一个代理对象"><a href="#目标视图控制器定义一个代理对象" class="headerlink" title="目标视图控制器定义一个代理对象"></a>目标视图控制器定义一个代理对象</h2><p>这里的目标视图就是本例子中的“另一个视图”。另一个视图的文件为：<code>JJAnotherViewController.h</code>、<code>JJAnotherViewController.m</code>和<code>JJAnotherViewController.xib</code>。</p>
<p>源代码分别为：</p>
<p><strong>JJAnotherViewController.h</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"UIViewPassValueDelegate.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JJAnotherViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *value;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> &lt;<span class="built_in">UIViewPassValueDelegate</span>&gt; delegate;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><strong>JJAnotherViewController.m</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"JJAnotherViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JJAnotherViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)backButton:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 需要传参的时候在目标窗口调用代理的协议方法</span></div><div class="line">    [<span class="keyword">self</span>.delegate passValue:<span class="keyword">self</span>.value.text];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>综上，我们来重新将上述过程总结成大白话。为了能把目标视图里的数据通过委托协议传递给主视图，其过程如下：</p>
<ol>
<li>定义协议，协议中声明了一个方法，该方法用于把目标视图里的数据传递给源视图；</li>
<li>分别创建源视图和目标视图的控制器，并搭建好各自的界面；</li>
<li>在目标视图控制器的头文件里导入协议头文件，并定义一个用来存储待传递的数据的属性，和一个代理属性；</li>
<li>在目标视图控制器的实现文件里调用其代理属性的协议方法，并把待传的数据作为参数传入该方法；</li>
<li>让源视图控制器成为目标视图控制器的代理对象，从而源视图就可以接收来自目标视图的数据了，方法是：<ol>
<li>在源视图控制器的头文件里导入协议文件的头文件；</li>
<li>在源视图控制器的头文件里遵守协议，即用尖括号声明；</li>
<li>实现协议方法，在协议方法里接收来自目标视图的数据。参数由该协议方法的参数传递过来；</li>
</ol>
</li>
</ol>
<p>注：</p>
<ul>
<li><p>协议：本例中的<em>UIViewPassValueDelegate.h</em></p>
</li>
<li><p>协议方法：本例中的<em>- (void)passValue:(NSString \</em>)value*</p>
</li>
<li><p>源视图：本例中的<em>JJMainViewController</em></p>
</li>
<li><p>目标视图：本例中的<em>JJAnotherViewController</em></p>
</li>
<li><p>待传递的数据：本例中的目标视图里的文本框里输入的数据</p>
</li>
<li><p>为了防止循环引用代理属性的标识符应为assign，为了让各种对象都能成为本对象的代理对象其类型应为id</p>
</li>
</ul>
<h3 id="进一步抽取"><a href="#进一步抽取" class="headerlink" title="进一步抽取"></a>进一步抽取</h3><p><strong>关键步骤一：</strong>定义协议，协议中定义好可以用来传参的方法，本协议也可以直接定义到主视图控制器的.h文件里<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewPassValueDelegate</span></span></div><div class="line"></div><div class="line"><span class="comment">// 本方法为传参时所需要的方法</span></div><div class="line">- (<span class="keyword">void</span>)passValue:(<span class="built_in">NSString</span> *)value;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><strong>关键步骤二：</strong>在主视图控制器的.m文件中把本控制器的对象设为代理对象<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">JJAnotherViewController *antherVC = [[JJAnotherViewController alloc] init];</div><div class="line"></div><div class="line">antherVC.delegate = <span class="keyword">self</span>;</div></pre></td></tr></table></figure></p>
<p><strong>关键步骤三：</strong>同时，在主视图控制器的.m文件中实现协议方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)passValue:(<span class="built_in">NSString</span> *)value &#123;</div><div class="line">    <span class="keyword">self</span>.valueField.text = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>关键步骤四：</strong>在另一个视图控制器的.h文件中引入协议，并定义代理属性<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIViewPassValueDelegate.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> &lt;<span class="built_in">UIViewPassValueDelegate</span>&gt; delegate;</div><div class="line"></div><div class="line">若代理协议是在“主视图控制器”的.h文件中定义的，则本步骤的代码如下方式：</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewPassValueDelegate</span>;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="keyword">id</span>&lt;KCMainDelegate&gt; delegate;</div></pre></td></tr></table></figure></p>
<p><strong>关键步骤五：</strong>最后，在另一个视图控制器的.m文件中调用代理属性的协议方法传递参数</p>
<pre><code class="objc">[<span class="keyword">self</span>.delegate passValue:<span class="keyword">self</span>.value.text];
</code></pre>
<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><ol>
<li><p><a href="http://www.cnblogs.com/kenshincui/p/3940746.html#autoid-4-0-0" target="_blank" rel="external">iOS开发系列–视图切换</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/heri/archive/2013/03/18/2965815.html" target="_blank" rel="external">ios页面间传递参数四种方式</a>    </p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Delegate/">Delegate</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/20/2015_08_20_DelegateForDatapass/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/20/2015_08_20_DelegateForDatapass/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/12/2016_07_12_GitNote/" title="Git 学习笔记" itemprop="url">Git 学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2016-07-11T16:00:00.000Z" itemprop="datePublished"> Published 2016-07-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一张图读懂-Git"><a href="#一张图读懂-Git" class="headerlink" title="一张图读懂 Git"></a>一张图读懂 Git</h2><p><strong><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="external">工作区和暂存区的概念 – 廖雪峰</a></strong></p>
<p><img src="/images/2016071201_git_learn_note_00.png" alt="2016071201_git_learn_note_00"></p>
<h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><p><strong><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">Git远程操作详解 – 阮一峰</a></strong></p>
<ul>
<li><code>git clone &lt;git地址&gt;</code>：本地没有repository时，将远程repository整个下载过来。</li>
<li><code>git pull</code>：本地有repository，将远程repository里新的commit数据(如有的话)下载过来，并且与本地代码merge。</li>
<li><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>：用于将本地分支的更新，推送到远程主机。如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。eg：<code>git push origin master</code></li>
<li><code>git fetch</code>：将远程仓库的更新同步到本地</li>
<li><p><code>git pull</code>：取回远程仓库某个分支的更新，再与本地的指定分支合并</p>
</li>
<li><p>查看分支：<code>git branch</code></p>
</li>
<li>创建分支：<code>git branch &lt;name&gt;</code></li>
<li>切换分支：<code>git checkout &lt;name&gt;</code></li>
<li>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></li>
<li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li>
<li><p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
</li>
<li><p>创建一个与本地分支同名的远程分支：</p>
<p>  $ git push origin &lt;本地分支名&gt; </p>
</li>
</ul>
<p><strong><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单 – 阮一峰</a></strong></p>
<h2 id="分支的创建、合并、删除图示"><a href="#分支的创建、合并、删除图示" class="headerlink" title="分支的创建、合并、删除图示"></a>分支的创建、合并、删除图示</h2><p><strong><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="external">分支的创建、合并、删除图示 – 廖雪峰</a></strong></p>
<p>假设原来只有 master 分支 ↓ ：<br><img src="/images/2016071201_git_learn_note_01.png" alt="2016071201_git_learn_note_01"></p>
<p>创建一个叫 dev 的新分支，并切换到该分支上 ↓ ：<code>git checkout -b dev</code><br><img src="/images/2016071201_git_learn_note_02.png" alt="2016071201_git_learn_note_02"></p>
<p>在 dev 分支上进行一次提交 ↓ ：<code>git commit -m &quot;在dev分支上提交更改&quot;</code><br><img src="/images/2016071201_git_learn_note_03.png" alt="2016071201_git_learn_note_03"></p>
<p>把 dev 合并到 master 上 ↓ ：<code>git merge dev</code><br><img src="/images/2016071201_git_learn_note_04.png" alt="2016071201_git_learn_note_04"></p>
<p>删除 dev 分支 ↓ ：<code>git branch -d dev</code><br><img src="/images/2016071201_git_learn_note_05.png" alt="2016071201_git_learn_note_05"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>master：</code></strong>主分支；</li>
<li><strong><code>HEAD：</code></strong>始终指向当前分支；</li>
<li>Git 创建、合并、删除分支非常快，因为这些操作都是对指针的操作，改改 HEAD 的指向，工作区的文件都没有任何变化；</li>
<li>Git 鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在 master 分支上工作效果是一样的，但过程更安全。</li>
</ul>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><ul>
<li><strong>fork 按钮：</strong>fork 用于将他人的仓库复制到我们账号中。如果我们想要参与开源项目，首先要 fork 下别人的项目，然后在我们复制过来的仓库中，对别人的代码做修改。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Git/">Git</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Git/">Git</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/12/2016_07_12_GitNote/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/12/2016_07_12_GitNote/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/22/2015_08_22_OCFragmentary/" title="OC：零碎知识总结" itemprop="url">OC：零碎知识总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-22T13:55:07.000Z" itemprop="datePublished"> Published 2015-08-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="判断编译环境：ARC还是MRC？"><a href="#判断编译环境：ARC还是MRC？" class="headerlink" title="判断编译环境：ARC还是MRC？"></a>判断编译环境：ARC还是MRC？</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if __has_feature(objc_arc)</span></div><div class="line"><span class="comment">// 当前编译环境是ARC</span></div><div class="line"></div><div class="line"><span class="meta">#else</span></div><div class="line"><span class="comment">// 当前编译环境是MRC</span></div><div class="line"></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<h2 id="UIView、UIWindow、CALayer"><a href="#UIView、UIWindow、CALayer" class="headerlink" title="UIView、UIWindow、CALayer"></a>UIView、UIWindow、CALayer</h2><ol>
<li>UIView：<ul>
<li>属于<code>UIKit.framework</code>框架；</li>
<li>负责显示内容；</li>
<li>可以响应触摸事件；</li>
</ul>
</li>
<li>UIWindow：<ul>
<li>属于<code>UIKit.framework</code>框架；</li>
<li>UIWindow是一种特殊的UIView，通常一个程序中只有一个UIWindow，但是可以手动创建多个UIWindow，并同时加到程序里面；</li>
<li>UIWindow主要有三个作用：<ul>
<li>作为容器，包含APP中所要显示的所有视图；</li>
<li>传递触摸消息到程序中的View和其他对象；</li>
<li>与UIViewController协同工作，方便完成设备方向旋转的支持；</li>
</ul>
</li>
</ul>
</li>
<li>CALayer：<ul>
<li>属于<code>QuartzCore.framework</code>框架；</li>
<li>负责绘制内容；</li>
<li>不能响应触摸事件；</li>
</ul>
</li>
</ol>
<h2 id="设置状态栏隐藏"><a href="#设置状态栏隐藏" class="headerlink" title="设置状态栏隐藏"></a>设置状态栏隐藏</h2><p>在程序的启动过程中隐藏状态栏，在info.plist文件中添加如下内容即可：</p>
<p><img src="/images/2015_08_22_OCFragmentary1.png" alt="图片"></p>
<p>在APP指定的控制器的视图上隐藏状态栏，在控制器添加如下方法即可：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)prefersStatusBarHidden &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="App-Icons苹果官方指南"><a href="#App-Icons苹果官方指南" class="headerlink" title="App Icons苹果官方指南"></a>App Icons苹果官方指南</h2><p><a href="https://developer.apple.com/library/ios/qa/qa1686/_index.html" target="_blank" rel="external">App Icons 苹果官方指南</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Fragmentary/">Fragmentary</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/22/2015_08_22_OCFragmentary/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/22/2015_08_22_OCFragmentary/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_Multithreading/" title="多线程编程之 概述" itemprop="url">多线程编程之 概述</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T12:48:54.000Z" itemprop="datePublished"> Published 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p><strong>主线程：</strong>应用程序启动时，最先执行的线程，用来描绘用户界面、处理触摸屏幕的事件等；</p>
<h3 id="并发性和并行性"><a href="#并发性和并行性" class="headerlink" title="并发性和并行性"></a>并发性和并行性</h3><p><strong>并行性（parallel）：</strong>同一时刻，有多条指令在多个处理器上同时执行；</p>
<p><strong>并发性（concurrency）：</strong>同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果；</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Multithreading/">Multithreading</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/17/2015_08_17_Multithreading/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/17/2015_08_17_Multithreading/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_GCD/" title="多线程编程之 GCD" itemprop="url">多线程编程之 GCD</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T12:27:35.000Z" itemprop="datePublished"> Published 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="GCD-中两个核心概念"><a href="#GCD-中两个核心概念" class="headerlink" title="GCD 中两个核心概念"></a>GCD 中两个核心概念</h2><ul>
<li><p><strong>队列：</strong>队列负责管理开发者提交的任务，队列始终以 FIFO（先进先出）的方式来处理任务，但由于任务的执行时间并不相同，因此处理的任务并不一定先结束。队列底层会维护一个线程池来处理用户提交的任务，线程池的作用就是<strong>执行</strong>队列管理的任务。</p>
</li>
<li><p><strong>任务：</strong>任务就是开发者提交给队列的<strong>工作单元</strong>，这些任务将会提交给队列底层维护的线程池执行。</p>
</li>
</ul>
<h2 id="GCD-中其它概念"><a href="#GCD-中其它概念" class="headerlink" title="GCD 中其它概念"></a>GCD 中其它概念</h2><p><strong>Dispatch Queue：</strong>执行处理的等待队列，按照追加的顺序（FIFO）执行处理。Dispatch Queue 分为 Serial Dispatch Queue 和 Concurrent Dispatch Queue；在不能改变执行的处理顺序或不想并发执行多个处理时使用 Serial Dispatch Queue。</p>
<p><strong>并行性（parallel）：</strong>同一时刻，有多条指令在多个处理器上同时执行；</p>
<p><strong>并发性（concurrency）：</strong>同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果；</p>
<p><strong>主线程：</strong>应用程序启动时，最先执行的线程，用来描绘用户界面、处理触摸屏幕的事件等。追加到主线程的处理在主线程的 RunLoop 中执行；</p>
<p>如果过多使用多线程，就会消耗大量内存，引起大量上下文切换，大幅度降低系统的响应性能；</p>
<h2 id="GCD-多线程编程的步骤"><a href="#GCD-多线程编程的步骤" class="headerlink" title="GCD 多线程编程的步骤"></a>GCD 多线程编程的步骤</h2><ul>
<li><p>创建队列；</p>
</li>
<li><p>创建任务，并将任务提交给队列；</p>
</li>
</ul>
<h2 id="Serial-Dispatch-Queue-和-Concurrent-Dispatch-Queue"><a href="#Serial-Dispatch-Queue-和-Concurrent-Dispatch-Queue" class="headerlink" title="Serial Dispatch Queue 和 Concurrent Dispatch Queue"></a>Serial Dispatch Queue 和 Concurrent Dispatch Queue</h2><p>当生成多个 Serial Dispatch Queue 时，各个 Serial Dispatch Queue 将并行执行。虽然在一个 Serial Dispatch Queue 中同时只能执行一个追加处理，但如果将10个处理分别追加到10个 Serial Dispatch Queue 中后，各个 Serial Dispatch Queue 执行一个追加处理，则能并发执行10个处理。</p>
<p>多个 Serial Dispatch Queue 同时执行会引发数据竞争问题。</p>
<p>当想并发执行又不发生数据竞争等问题的处理时，使用 Concurrent Dispatch Queue。</p>
<h2 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h2><pre><code>dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
</code></pre><p><strong>第一个参数const char *label：</strong>指定队列的名称，该名称推荐使用逆序全程域名（FQDN，fully qualified domain name）例如<code>com.example.gcd.MyConcurrentDispatchQueue</code>。该名称在 Xcode 和 Instruments 的调试器中作为 Dispatch Queue 名称表示。另外该名称也出现在应用程序崩溃时所生成的CrashLog中。</p>
<p><strong>第二个参数dispatch_queue_attr_t attr：</strong>指定队列的类型，即 Serial Dispatch Queue 或 Concurrent Dispatch Queue。当参数为NULL时为串行队列，当参数为DISPATCH_QUEUE_CONCURRENT时为并发队列。</p>
<pre><code>// 创建一个 Serial Dispatch Queue
dispatch_queue_t mySDQ = dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue&quot;, NULL);

// 创建一个 Concurrent Dispatch Queue
dispatch_queue_t myCDQ = dispatch_queue_create(&quot;com.example.gcd.MyConcurrentDispatchQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
</code></pre><p>ARC机制下不需要调用<code>void dispatch_release(dispatch_object_t object);</code>方法进行手动释放；    </p>
<h2 id="Main-Dispatch-Queue-和-Global-Dispatch-Queue"><a href="#Main-Dispatch-Queue-和-Global-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue 和 Global Dispatch Queue"></a>Main Dispatch Queue 和 Global Dispatch Queue</h2><p>Main Dispatch Queue 和 Global Dispatch Queue 是系统标准提供的 Dispatch Queue。</p>
<h3 id="Main-Dispatch-Queue"><a href="#Main-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue"></a>Main Dispatch Queue</h3><p><strong>Main Dispatch Queue：</strong>在主线程中执行的 Dispatch Queue，本质上是 Serial Dispatch Queue，追加到 Main Dispatch Queue 的处理在主线程的 RunLoop 中执行；</p>
<h5 id="dispatch-get-main-queue-方法"><a href="#dispatch-get-main-queue-方法" class="headerlink" title="dispatch_get_main_queue 方法"></a>dispatch_get_main_queue 方法</h5><pre><code>dispatch_queue_t dispatch_get_main_queue(void)
{
    return DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q);
}

其中

#define DISPATCH_GLOBAL_OBJECT(type, object) ((OS_OBJECT_BRIDGE type)&amp;(object))

#define OS_OBJECT_BRIDGE __bridge

struct dispatch_queue_s _dispatch_main_q;

也就是

dispatch_queue_t dispatch_get_main_queue(void)
{
    return (__bridge dispatch_queue_t) &amp; _dispatch_main_q;
}
</code></pre><p>举例：</p>
<pre><code>dispatch_queue_t mainDQ = dispatch_get_main_queue();
</code></pre><h3 id="Global-Dispatch-Queue"><a href="#Global-Dispatch-Queue" class="headerlink" title="Global Dispatch Queue"></a>Global Dispatch Queue</h3><p><strong>Global Dispatch Queue：</strong>是所有应用程序都能够使用的 Concurrent Dispatch Queue。没有必要通过 dispatch_queue_create 逐个生成 Concurrent Dispatch Queue，只要获取 Global Dispatch Queue 使用即可；</p>
<h5 id="dispatch-get-global-queue-方法"><a href="#dispatch-get-global-queue-方法" class="headerlink" title="dispatch_get_global_queue 方法"></a>dispatch_get_global_queue 方法</h5><pre><code>dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);
</code></pre><p>第二个参数 unsigned long flags：额外的旗标参数，暂未使用，只是为将来准备的，一般传入0即可；</p>
<h5 id="Global-Dispatch-Queue-有4个执行优先级"><a href="#Global-Dispatch-Queue-有4个执行优先级" class="headerlink" title="Global Dispatch Queue 有4个执行优先级"></a>Global Dispatch Queue 有4个执行优先级</h5><pre><code>DISPATCH_QUEUE_PRIORITY_HIGH 2
DISPATCH_QUEUE_PRIORITY_DEFAULT 0
DISPATCH_QUEUE_PRIORITY_LOW (-2)
DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN
</code></pre><p>举例：</p>
<pre><code>dispatch_queue_t globalDQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</code></pre><h2 id="dispatch-asyc-和-dispatch-syc"><a href="#dispatch-asyc-和-dispatch-syc" class="headerlink" title="dispatch_asyc 和 dispatch_syc"></a>dispatch_asyc 和 dispatch_syc</h2><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p>将处理在指定时间追加到 Dispatch Queue。经常和dispatch_time一起使用：</p>
<h4 id="dispatch-time"><a href="#dispatch-time" class="headerlink" title="dispatch_time"></a>dispatch_time</h4><pre><code>dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);
</code></pre><p>第一个参数 dispatch_time_t when：用来指定开始时间，经常用的参数是<code>DISPATCH_TIME_NOW</code>和<code>DISPATCH_TIME_FOREVER</code>；</p>
<pre><code>typedef uint64_t dispatch_time_t;

#define DISPATCH_TIME_NOW (0ull)
#define DISPATCH_TIME_FOREVER (~0ull)
</code></pre><p>第二个参数 int64_t delta：用来指定偏移时长，单位为纳秒，比如<code>3ull * NSEC_PER_SEC</code>表示<code>3 * 1000000000纳秒 = 3秒</code>；</p>
<pre><code>typedef    long long  int64_t;

#define NSEC_PER_SEC  1000000000ull  // 10的9次方，纳秒是10的-9次方
#define NSEC_PER_MSEC 1000000ull
#define USEC_PER_SEC  1000000ull
#define NSEC_PER_USEC 1000ull
</code></pre><p>其中数字后面的后缀ull表示unsigned long long；</p>
<h4 id="dispatch-after-1"><a href="#dispatch-after-1" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><pre><code>void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);
</code></pre><p>举例，在 3 秒后把某个指定的 Block 追加到 Main Dispatch Queue 中：</p>
<pre><code>dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);

dispatch_after(time, dispatch_get_main_queue(), ^{
    NSLog(@&quot;3秒后把本操作追加到 Main Dispatch Queue 中执行&quot;);
});
</code></pre><p>也可以将 dispatch_time 和 dispatch_after 两个方法合并起来用，这也是比较常用的方式：</p>
<pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3ull * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    NSLog(@&quot;3秒后把本操作追加到 Main Dispatch Queue 中执行&quot;);
});  
</code></pre><h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h2><p>用来变更 Dispatch Queue 的执行优先级（或执行层次）。</p>
<pre><code>void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);
</code></pre><p>第一个参数 dispatch_object_t object：被改变对象；</p>
<p>第二个参数 dispatch_queue_t queue：（目标）参考优先级。</p>
<p>将 dispatch_object_t object 的优先级改为与 dispatch_queue_t queue 的优先级相同；</p>
<p>举例：</p>
<pre><code>dispatch_queue_t mySDQ = dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue&quot;, NULL);

dispatch_queue_t myGDQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);

dispatch_set_target_queue(mySDQ, myGDQ);
</code></pre><p><strong>使用场景举例：</strong></p>
<p>有几个不可并发执行的处理，但是因为某种原因必须追加到多个 Serial Dispatch Queue 中时，会产生不可预期的后果，但是如果用dispatch_set_target_queue函数将目标指定为某一个 Serial Dispatch Queue，即可防止处理并发执行。但目前为止尚未遇到过这种情况。</p>
<h2 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h2><h2 id="dispatch-barrier-asyc"><a href="#dispatch-barrier-asyc" class="headerlink" title="dispatch_barrier_asyc"></a>dispatch_barrier_asyc</h2><h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><h2 id="dispatch-suspend-和-dispatch-resume"><a href="#dispatch-suspend-和-dispatch-resume" class="headerlink" title="dispatch_suspend 和 dispatch_resume"></a>dispatch_suspend 和 dispatch_resume</h2><h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h2><p>dispatch_once 函数的作用是在整个应用程序的生命周期中只执行一次代码块，而且是线程同步的，即不需要再使用@synchronized 之类的语句。</p>
<h2 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h2><h2 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h2>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/GCD/">GCD</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/17/2015_08_17_GCD/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/17/2015_08_17_GCD/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_NSOperation/" title="多线程编程之 NSOperation" itemprop="url">多线程编程之 NSOperation</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T07:31:01.000Z" itemprop="datePublished"> Published 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong>NSOperationQueue：</strong></p>
<p>NSOperationQueue 代表一个 FIFO 队列，它负责管理、执行添加的多个 NSOperation。NSOperationQueue底层维护了一个线程池，它会按顺序启动线程来执行提交给该队列的NSOperation任务。</p>
<p><strong>NSOperation：</strong></p>
<p>NSOperation 代表一个多线程任务，每个 NSOperation 中又可以封装多个待执行的操作。</p>
<p><strong>使用NSOperation与NSOperationQueue实现多线程编程的步骤：</strong></p>
<p>步骤一：先创建一个 NSOperationQueue 队列（主队列或非主队列）；</p>
<p>步骤二：创建一个 NSOperation 子类的对象，把需要执行的操作封装到 NSOperation 中；</p>
<p>步骤三：把封装后的 NSOperation 添加到 NSOperationQueue 队列中；</p>
<p>接下来系统会自动地将 NSOperationQueue 队列中的 NSOperation 取出，把封装到 NSOperation 中的操作放到线程里去执行；</p>
<h2 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h2><h3 id="有两种-NSOperationQueue-队列类型："><a href="#有两种-NSOperationQueue-队列类型：" class="headerlink" title="有两种 NSOperationQueue 队列类型："></a>有两种 NSOperationQueue 队列类型：</h3><p><strong>1&gt; 主队列</strong></p>
<pre><code>NSOperationQueue *queue = [NSOperationQueue mainQueue];
</code></pre><p>添加到主队列中的操作，都会放到主线程中执行，调用的是类方法<code>+ (NSOperationQueue *)mainQueue;</code></p>
<p><strong>2&gt; 非主队列</strong></p>
<pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];
</code></pre><p>添加到非主队列中的操作，都会开辟新线程异步并发执行</p>
<h3 id="往队列里添加任务的三种方式："><a href="#往队列里添加任务的三种方式：" class="headerlink" title="往队列里添加任务的三种方式："></a>往队列里添加任务的三种方式：</h3><pre><code>// 将 NSOperation 添加到队列中
-(void)addOperation:(NSOperation *)op;

// 将 Block 添加到队列中
-(void)addOperationWithBlock:(void (^)(void))block;

// 将 NSArray 中所有的 NSOperation 添加到队列中
// wait 为 YES，将会阻塞当前线程，直到提交的所有的 NSOperation 执行完成
// wait 为 NO，该方法会立即返回，NSArray 中包含的所有 NSOperation 将以异步方式执行，不会阻塞当前线程
-(void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait;
</code></pre><p>举例：</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;---下载1---%@&quot;, [NSThread currentThread]);
    }];

    NSInvocationOperation *operation2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download:) object:@&quot;下载&quot;];

    [queue addOperation:operation1];
    [queue addOperation:operation2];

    [queue addOperationWithBlock:^{
        NSLog(@&quot;---下载3---%@&quot;, [NSThread currentThread]);
    }];

}

- (void)download:(NSString *)string
{
    NSLog(@&quot;---%@2---%@&quot;,string ,[NSThread currentThread]);
}


输出如下：

2015-08-17 18:57:43.698 SingleViewAPPTest[3951:1080191] ---下载1---&lt;NSThread: 0x7ff669204140&gt;{number = 2, name = (null)}
2015-08-17 18:57:43.698 SingleViewAPPTest[3951:1080192] ---下载3---&lt;NSThread: 0x7ff668c2c010&gt;{number = 3, name = (null)}
2015-08-17 18:57:43.698 SingleViewAPPTest[3951:1080190] ---下载2---&lt;NSThread: 0x7ff668c2c290&gt;{number = 4, name = (null)}
</code></pre><h3 id="NSOperationQueue-的其它方法"><a href="#NSOperationQueue-的其它方法" class="headerlink" title="NSOperationQueue 的其它方法"></a>NSOperationQueue 的其它方法</h3><h4 id="最大并发数"><a href="#最大并发数" class="headerlink" title="最大并发数"></a>最大并发数</h4><pre><code>// 返回该 NSOperationQueue 队列支持的最大并发数量，即最大支持多少个并发线程
- (NSInteger)maxConcurrentOperationCount;

// 设置该 NSOperationQueue 队列支持的最大并发数量，即最大支持多少个并发线程
- (void)setMaxConcurrentOperationCount:(NSInteger)count;
</code></pre><p><code>maxConcurrentOperationCount</code>和<code>setMaxConcurrentOperationCount:</code>其实就是<code>maxConcurrentOperationCount</code>属性的getter、setter方法——专门用来控制 NSOperationQueue 所支持的最大并发数量。</p>
<h4 id="取消队列"><a href="#取消队列" class="headerlink" title="取消队列"></a>取消队列</h4><p>本方法用于取消 NSOperationQueue 队列中所有正在排队和执行的 NSOperation，是不可恢复。一般当有内存警告时用于取消所有任务。而NSOperation 的 cancel方法用于取消单个 operation。</p>
<pre><code>- (void)cancelAllOperations;
</code></pre><h4 id="暂停任务"><a href="#暂停任务" class="headerlink" title="暂停任务"></a>暂停任务</h4><pre><code>// 判断 NSOperationQueue 是否已暂停调度正在排队的 NSOperation
- (BOOL)isSuspended;

// 设置 NSOperationQueue 是否暂停调度正在排队的 NSOperation
// 当前后台切换或滚动操作时使用，用来暂停和恢复队列
- (void)setSuspended:(BOOL)suspend;
</code></pre><p>同样的，<code>isSuspended</code>和<code>setSuspended:</code>方法也是<code>suspended</code>属性的getter、setter方法。</p>
<h4 id="返回当前的队列"><a href="#返回当前的队列" class="headerlink" title="返回当前的队列"></a>返回当前的队列</h4><pre><code>// 返回执行当前 NSOperation 的 NSOperationQueue 队列
+ (NSOperationQueue *)currentQueue;
</code></pre><h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><pre><code>// 阻塞当前线程，直到该 NSOperationQueue 中所有排队和执行的 NSOperation 执行完成才接触阻塞
- (void)waitUntilAllOperationsAreFinished;
</code></pre><h3 id="NSOperationQueue-的属性"><a href="#NSOperationQueue-的属性" class="headerlink" title="NSOperationQueue 的属性"></a>NSOperationQueue 的属性</h3><pre><code>@property (readonly, copy) NSArray *operations;

@property (readonly) NSUInteger operationCount;

@property NSInteger maxConcurrentOperationCount;

@property (getter=isSuspended) BOOL suspended;

@property (copy) NSString *name;

@property NSQualityOfService qualityOfService;

@property (assign) dispatch_queue_t underlyingQueue;  /* assing actually retain */
</code></pre><h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p>NSOperation 是一个抽象类，并不具备封装操作的能力，必须使用它的子类。NSOperation 有两种使用方式：</p>
<p>1&gt; 直接使用子类 NSInvocationOperation 或者子类 NSBlockOperation；</p>
<p>2&gt; 开发者自己实现 NSOperation 子类；</p>
<h3 id="NSOperation-的方法"><a href="#NSOperation-的方法" class="headerlink" title="NSOperation 的方法"></a>NSOperation 的方法</h3><h4 id="开启操作"><a href="#开启操作" class="headerlink" title="开启操作"></a>开启操作</h4><pre><code>- (void)start;
</code></pre><p>只有一个 operation，这个 operation 又只有一个操作时，直接调用 start 方法，会在当前线程中同步执行；</p>
<p>只有一个 operation，但这个 operation 有多个操作时，这些操作会异步并发执行，而且其中的一个操作会在当前线程中执行；</p>
<pre><code>NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;---下载1---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载2---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载3---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载4---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载5---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载6---%@&quot;, [NSThread currentThread]);
}];

[operation addExecutionBlock:^{
    NSLog(@&quot;---下载7---%@&quot;, [NSThread currentThread]);
}];

[operation start];

输出为：

2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960381] ---下载2---&lt;NSThread: 0x7fcfc3d1cdf0&gt;{number = 2, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960389] ---下载7---&lt;NSThread: 0x7fcfc502ad90&gt;{number = 5, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960382] ---下载1---&lt;NSThread: 0x7fcfc3e13360&gt;{number = 6, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960387] ---下载5---&lt;NSThread: 0x7fcfc3d248a0&gt;{number = 7, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960386] ---下载4---&lt;NSThread: 0x7fcfc5100590&gt;{number = 4, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960388] ---下载6---&lt;NSThread: 0x7fcfc3d207d0&gt;{number = 3, name = (null)}
2015-08-17 18:19:29.106 SingleViewAPPTest[3494:960346] ---下载3---&lt;NSThread: 0x7fcfc3e0f900&gt;{number = 1, name = main}
</code></pre><p>结论1：这个 operation 必然会有一个操作是在当前线程中执行；</p>
<p>结论2：这个 operation 的所有操作都是并发执行的；</p>
<p>结论3：不会限制最大并发数，有多少个操作就开多少个线程（放到队列里默认也不限制最大并发数）；    </p>
<h4 id="取消操作"><a href="#取消操作" class="headerlink" title="取消操作"></a>取消操作</h4><pre><code>- (void)cancel;
</code></pre><h4 id="设置依赖"><a href="#设置依赖" class="headerlink" title="设置依赖"></a>设置依赖</h4><pre><code>// 设置 NSOperation 之间的依赖来保证执行顺序
// 例如[operationA addDependency:operationB]，给 operationA 添加了依赖
// 即 operationA 依赖于 operationB，只有等 operationB 执行完毕了才会执行 operationA
- (void)addDependency:(NSOperation *)op;

- (void)removeDependency:(NSOperation *)op;
</code></pre><ul>
<li><p>注意：不能相互依赖，比如 A 依赖 B，B 又依赖 A;</p>
</li>
<li><p>可以在不同的 NSOperationQueue 之间创建依赖关系;</p>
</li>
</ul>
<p>使用举例：</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];

    NSBlockOperation *operationA = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;---下载A---%@&quot;, [NSThread currentThread]);
    }];

    NSInvocationOperation *operationB = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(download:) object:@&quot;B&quot;];


    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];

    NSBlockOperation *operationC = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;---下载C---%@&quot;, [NSThread currentThread]);
    }];

    [operationB addDependency:operationC];
    [operationA addDependency:operationB];

    [queue1 addOperation:operationA];
    [queue1 addOperation:operationB];
    [queue2 addOperation:operationC];

}

- (void)download:(NSString *)string
{
    NSLog(@&quot;---下载%@---%@&quot;,string ,[NSThread currentThread]);
}

@end

输出如下：

2015-08-17 19:10:53.235 SingleViewAPPTest[4139:1132032] ---下载C---&lt;NSThread: 0x7fbb69904e80&gt;{number = 2, name = (null)}
2015-08-17 19:10:53.235 SingleViewAPPTest[4139:1132032] ---下载B---&lt;NSThread: 0x7fbb69904e80&gt;{number = 2, name = (null)}
2015-08-17 19:10:53.236 SingleViewAPPTest[4139:1132032] ---下载A---&lt;NSThread: 0x7fbb69904e80&gt;{number = 2, name = (null)}
</code></pre><h4 id="等待执行完毕"><a href="#等待执行完毕" class="headerlink" title="等待执行完毕"></a>等待执行完毕</h4><pre><code>- (void ^(void))completionBlock;

// operation 的所有操作都执行完后立即开辟新线程来执行本方法的 Block 里的内容
// 本方法实际上是 (^completionBlock)(void) 属性的setter方法
- (void)setCompletionBlock:(void (^)(void)())block;
</code></pre><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><pre><code>- (void)main;

- (void)waitUntilFinished;
</code></pre><h3 id="NSOperation-的属性"><a href="#NSOperation-的属性" class="headerlink" title="NSOperation 的属性"></a>NSOperation 的属性</h3><pre><code>@property (readonly, getter=isCancelled) BOOL cancelled;

@property (readonly, getter=isExecuting) BOOL executing;

@property (readonly, getter=isFinished) BOOL finished;

@property (readonly, getter=isConcurrent) BOOL concurrent;

@property (readonly, getter=isAsynchronous) BOOL asynchronous;

@property (readonly, getter=isReady) BOOL ready;

@property (readonly, copy) NSArray *dependencies;

@property NSOperationQueuePriority queuePriority;

@property (copy) void (^completionBlock)(void);

@property double threadPriority;

@property NSQualityOfService qualityOfService;

@property (copy) NSString *name ;
</code></pre><h2 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h2><p>NSInvocationOperation 和 NSBlockOperation 都是 NSOperation 的子类，都可在程序中直接使用，用于封装需要异步执行的任务。NSInvocationOperation 用于将<strong>特定对象</strong>的<strong>特定方法</strong>封装成 NSOperation。</p>
<h3 id="NSInvocationOperation-的方法"><a href="#NSInvocationOperation-的方法" class="headerlink" title="NSInvocationOperation 的方法"></a>NSInvocationOperation 的方法</h3><pre><code>- (instancetype)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;

- (instancetype)initWithInvocation:(NSInvocation *)inv;
</code></pre><h3 id="NSInvocationOperation-的属性"><a href="#NSInvocationOperation-的属性" class="headerlink" title="NSInvocationOperation 的属性"></a>NSInvocationOperation 的属性</h3><pre><code>@property (readonly, retain) NSInvocation *invocation;

@property (readonly, retain) id result;
</code></pre><h2 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h2><h3 id="NSBlockOperation-的方法"><a href="#NSBlockOperation-的方法" class="headerlink" title="NSBlockOperation 的方法"></a>NSBlockOperation 的方法</h3><pre><code>+ (instancetype)blockOperationWithBlock:(void (^)(void))block;

- (void)addExecutionBlock:(void (^)(void))block;
</code></pre><h3 id="NSBlockOperation-的属性"><a href="#NSBlockOperation-的属性" class="headerlink" title="NSBlockOperation 的属性"></a>NSBlockOperation 的属性</h3><pre><code>@property (readonly, copy) NSArray *executionBlocks;
</code></pre><h2 id="自定义的-NSOperation-的子类"><a href="#自定义的-NSOperation-的子类" class="headerlink" title="自定义的 NSOperation 的子类"></a>自定义的 NSOperation 的子类</h2><p>除了使用已经提供的 NSOperation 的两个子类外，开发者也可以自定义NSOperation 的子类，但是本方法比较少用。具体步骤如下：</p>
<p>1&gt; 创建一个类，继承自 NSOperation；</p>
<p>2&gt; 重写<code>- (void)main</code>方法，在本方法里实现要执行的任务；</p>
<h2 id="回到主线程的三种方式"><a href="#回到主线程的三种方式" class="headerlink" title="回到主线程的三种方式"></a>回到主线程的三种方式</h2><h3 id="用performSelector-方法"><a href="#用performSelector-方法" class="headerlink" title="用performSelector 方法"></a>用performSelector 方法</h3><pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    [queue addOperationWithBlock:^{
        // 下载下载图片

        // 回到主线程
        [self performSelectorOnMainThread:@selector(download:) withObject:@&quot;已经回到主线程&quot; waitUntilDone:YES];

    }];
}

- (void)download:(NSString *)string
{
    NSLog(@&quot;%@&quot;, string);
}
</code></pre><h3 id="用GCD"><a href="#用GCD" class="headerlink" title="用GCD"></a>用GCD</h3><pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];

[queue addOperationWithBlock:^{
    // 下载下载图片

    // 回到主线程
    dispatch_async(dispatch_get_main_queue(), ^{
        // 回到主线程后执行的操作
    });

}];
</code></pre><h3 id="用-NSOperationQueue"><a href="#用-NSOperationQueue" class="headerlink" title="用 NSOperationQueue"></a>用 NSOperationQueue</h3><pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];

[queue addOperationWithBlock:^{
    // 下载下载图片

    // 回到主线程
    [[NSOperationQueue mainQueue] addOperationWithBlock:^{
        // 回到主线程后执行的操作
    }];

}];
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/NSOperation/">NSOperation</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/17/2015_08_17_NSOperation/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/17/2015_08_17_NSOperation/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_CFragmentary/" title="C 语言：零碎知识总结" itemprop="url">C 语言：零碎知识总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T02:48:28.000Z" itemprop="datePublished"> Published 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数。</p>
<pre><code>// 定义回调函数1
void PrintfText()
{
    printf(&quot;Hello World!\n&quot;);
}

// 定义回调函数2
void PrintfInt()
{
    printf(&quot;10\n&quot;);
}

// 定义实现回调函数的&quot;调用函数&quot;
void CallPrintf(void (*callfuct)(void))
{
    callfuct();
}

// 在main函数中实现函数回调
int main(int argc,char* argv[])
{
    CallPrintf(PrintfText);
    CallPrintf(PrintfInt);
    return 0;
}
</code></pre>
        
        
        <p class="article-more-link">
          
            <a href="/2015/08/17/2015_08_17_CFragmentary/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/17/2015_08_17_CFragmentary/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/17/2015_08_17_CFragmentary/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2015_08_16_NSStringIsEqual/" title="isEqual 和 == 的比较" itemprop="url">isEqual 和 == 的比较</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T11:45:53.000Z" itemprop="datePublished"> Published 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>== 和 isEqual 都是用来判断连个变量是否相等；</p>
<h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>1.<code>数值型</code>的基本类型变量比较：不一定要求数据类型严格相同，只要值相等，则返回真；</p>
<p>例如：<code>int型50 == float型50.0f；</code></p>
<p>2.<code>指针类型</code>变量比较：必须指向同一个对象，即两个指针变量保存的内存地址相同，返回真；</p>
<p>3.没有继承关系的两个指针变量比较：编译时提示警告；</p>
<h2 id="isEqual"><a href="#isEqual" class="headerlink" title="isEqual"></a>isEqual</h2><p>1.<code>指针类型</code>变量比较：同 ==，都是必须指向同一个对象，即两个指针变量保存的内存地址相同，返回真；</p>
<p>2.NSString 的 isEqual 方法：只要两个字符串包含相同的字符串序列，则返回真；</p>
<p>因为 isEqual 方法就指针类型变量的比较，本身与 == 没有区别，同时没有太大的意义，所以 NSString 重写了该方法，实现了值比较而不是地址比较。我们在编程时同样可以重写该方法来满足我们所要求的比较方式；</p>
<h2 id="字符型常量"><a href="#字符型常量" class="headerlink" title="字符型常量"></a>字符型常量</h2><p>像类似于<code>@&quot;hello&quot;</code>这种字符型常量是由常量池来存储管理的，常量池可以保证相同的字符串直接量只有一个；</p>
<p>而<code>[NSString stringWithFormat:@&quot;hello&quot;]</code>类型的字符串对象是运行时创建出来的，它被保存在运行时内存区（即堆内存），不会放入常量池中；</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/isEqual/">isEqual</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2015_08_16_NSStringIsEqual/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2015_08_16_NSStringIsEqual/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2015_08_16_NSString/" title="NSString 转换" itemprop="url">NSString 转换</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T11:12:14.000Z" itemprop="datePublished"> Published 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="其它-——-gt-NSString"><a href="#其它-——-gt-NSString" class="headerlink" title="其它 ——&gt; NSString"></a>其它 ——&gt; NSString</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSStringFromRange</span>( <span class="built_in">NSRange</span> range );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromRect</span>( <span class="built_in">NSRect</span> aRect );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromSelector</span>( SEL aSelector );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromClass</span>( __<span class="keyword">unsafe_unretained</span> Class aClass );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromProtocol</span>( Protocol *proto );</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSStringFromHashTable</span>( <span class="built_in">NSHashTable</span> *table );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromMapTable</span>( <span class="built_in">NSMapTable</span> *table );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromPoint</span>( <span class="built_in">NSPoint</span> aPoint );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromSize</span>( <span class="built_in">NSSize</span> aSize );</div></pre></td></tr></table></figure>
<p>举例：</p>
<pre><code>NSString *string = NSStringFromClass([NSArray class]);

NSLog(@&quot;NSArray 的类名是：%@&quot;,string);

输出如下：

2015-08-18 16:10:17.908 NewCommandTest[845:137450] NSArray 的类名是：NSArray
</code></pre><h2 id="NSNumber-——-gt-NSString"><a href="#NSNumber-——-gt-NSString" class="headerlink" title="NSNumber ——&gt; NSString"></a>NSNumber ——&gt; NSString</h2><pre><code>NSNumber *number = [NSNumber numberWithInt:20];

// 转换方法1
NSString *string = [number description];

// 转换方法2
NSString *string = [NSString stringWithFormat:@&quot;%d&quot;, [number intValue]];
</code></pre><p>本例是将<code>@20</code>转换为<code>@&quot;20&quot;</code>。</p>
<h2 id="NSData-——-gt-NSString"><a href="#NSData-——-gt-NSString" class="headerlink" title="NSData ——&gt; NSString"></a>NSData ——&gt; NSString</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.baidu.com"</span>]];</div><div class="line">       </div><div class="line"><span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
            <a href="/2015/08/16/2015_08_16_NSString/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C/">Objective-C</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/NSString/">NSString</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2015_08_16_NSString/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2015_08_16_NSString/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2016_09_22_Blocks/" title="Blosks 浅析" itemprop="url">Blosks 浅析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T07:28:30.000Z" itemprop="datePublished"> Published 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-Blocks概要"><a href="#1-Blocks概要" class="headerlink" title="1 Blocks概要"></a>1 Blocks概要</h2><p>带有自动变量（局部变量）的匿名函数（在标准的C和Objective-C语言中是不允许有匿名函数的）。</p>
<p>C语言中的变量类型：</p>
<p>1.自动变量Automatic variables（局部变量local variables）</p>
<p>2.静态变量Static variables（静态局部变量static local variables）</p>
<p>3.全局变量Global variables</p>
<p>4.静态全局变量Static global variables</p>
<p>5.函数的参数Function arguments</p>
<p>其中，在函数的多次调用之间能够传递值的变量有：</p>
<p>1.静态变量（静态局部变量）</p>
<p>2.静态全局变量</p>
<p>3.全局变量</p>
<h2 id="2-Blocks模式"><a href="#2-Blocks模式" class="headerlink" title="2 Blocks模式"></a>2 Blocks模式</h2><h3 id="2-1-Blocks语法"><a href="#2-1-Blocks语法" class="headerlink" title="2.1 Blocks语法"></a>2.1 Blocks语法</h3><p>完整形式的Block语法与C语言函数相比，仅有两点区别：</p>
<p>（1）没有函数名。</p>
<p>（2）带有插入记号“^”。</p>
<h4 id="完整形式的Block语法格式："><a href="#完整形式的Block语法格式：" class="headerlink" title="完整形式的Block语法格式："></a>完整形式的Block语法格式：</h4><pre><code>^ 返回值类型 参数列表 表达式
</code></pre><p>例如：    </p>
<pre><code>^int (int count) {return count + 1;}
</code></pre><h4 id="省略返回值类型的Block语法格式："><a href="#省略返回值类型的Block语法格式：" class="headerlink" title="省略返回值类型的Block语法格式："></a>省略返回值类型的Block语法格式：</h4><pre><code>^ 参数列表 表达式
</code></pre><h4 id="省略返回值类型时则Block的返回值类型为："><a href="#省略返回值类型时则Block的返回值类型为：" class="headerlink" title="省略返回值类型时则Block的返回值类型为："></a>省略返回值类型时则Block的返回值类型为：</h4><p>1.如果表达式没有return语句，则Block的返回值类型为void；</p>
<p>2.如果表达式有return语句，则Block的返回值类型就是return的类型；</p>
<p>3.如果表达式有多个return语句，则所有return的类型必须相同；</p>
<p>例如：</p>
<pre><code>^(int count) {return count + 1;}
</code></pre><h4 id="省略返回值类型和参数列表的Block语法格式："><a href="#省略返回值类型和参数列表的Block语法格式：" class="headerlink" title="省略返回值类型和参数列表的Block语法格式："></a>省略返回值类型和参数列表的Block语法格式：</h4><pre><code>^ 表达式
</code></pre><p>当不使用参数时，参数列表可以省略。</p>
<p>例如：</p>
<pre><code>^{printf(&quot;Blocks&quot;);}
</code></pre><h3 id="2-2-Block类型变量"><a href="#2-2-Block类型变量" class="headerlink" title="2.2 Block类型变量"></a>2.2 Block类型变量</h3><p>函数指针类型变量举例：    </p>
<pre><code>int func(int count)
{
    return count + 1;
}

int (*funcptr)(int) = &amp;func;

funcptr(5);
</code></pre><p>类似地，可将Block literal赋值给Block-type变量。When a Block literal is in source code, a value is generated. The value can be assigned to a variable of the Block type. In Blocks, the generated value is called Block as well. “Block”既指Block literal itself in a source code，也指the value generated from the Block literal.</p>
<p>Block类型变量举例：</p>
<pre><code>int (^blk)(int) = ^int (int count){return count + 1;};

blk(5);
</code></pre><p>注意，Block代码块不能像函数一样在外面定义，只能像一个表达式一样使用，比如定义完了立即赋给一个Block类型变量，或者作为函数的返回值。这里的Block就是生成的value。</p>
<p>Block类型变量与一般的C语言变量完全相同，都可以用作自动变量、静态变量、全局变量、静态全局变量、函数参数：</p>
<pre><code>1、将Block赋值给Block类型变量：

int (^blk)(int) = ^int (int count){return count + 1;};   

2、将Block类型变量赋值给Block类型变量：

int (^blk1)(int) = blk;

int (^blk2)(int);

blk2 = blk;

3、将Block类型变量作为函数参数来向函数传递Block：

void func(int (^blk)(int))

{
    // 执行代码...
}

4、将Block作为函数的返回值返回：

int (^func())(int)

{
    // 执行代码...
    return ^int (int count){return count + 1;};
}

5、也可以定义Block的指针类型变量：

typedef int (^blk_t)(int);

blk_t blk = ^int (int count){return count + 1;};

blk_t *blkptr = &amp;blk;

(*blkptr)(10);
</code></pre><h3 id="2-3-截获自动变量值和-block说明符"><a href="#2-3-截获自动变量值和-block说明符" class="headerlink" title="2.3 截获自动变量值和__block说明符"></a>2.3 截获自动变量值和__block说明符</h3><p>基本类型变量的截获：</p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    int val = 10; 

    void (^blk)(void) = ^{printf(&quot;%d\n&quot;, val);};   // 在这里截获自动变量val的值 

    blk();  // 输出10，注意不要写成blk;

    val = 2;

    blk();  // 输出也是10
}
</code></pre><p>Block语法使用了自动变量val的值，即Block语法保存了该自动变量的瞬间值，在执行完Block语法后，即使改写了Block中使用的自动变量的值也不会影响Block执行时的自动变量的值，称之为“截获自动变量的值”。</p>
<p>When automatic variables are captured, the values are read-only in the Block. 在上例的Block语法里尝试将val的值改为1时，会产生变异错误。</p>
<p>在自动变量前面加上__block说明符后，就可在Block里和Block外修改该自动变量的值而影响到Block。    </p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    __block int val = 10;

    void (^blk)(void) = ^{printf(&quot;%d\n&quot;, val);};   // 在这里截获自动变量val的值 

    blk();  // 输出10

    val = 2;

    blk();  // 输出2
}
</code></pre><p>以及：    </p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    __block int val = 10;

    void (^blk)(void) = ^{

        val = 1;

        printf(&quot;%d\n&quot;, val);

    };

    blk();  // 输出1

}
</code></pre><h4 id="对象类型变量的截获："><a href="#对象类型变量的截获：" class="headerlink" title="对象类型变量的截获："></a>对象类型变量的截获：</h4><pre><code>1、截获OC对象后，调用该对象的方法来修改该对象（使用截获的值），没有任何问题：

    id array = [[NSMutableArray alloc] init];

    void (^blk)(void) = ^{

        id obj = [[NSObject alloc] init];

            [array addObject:obj];  // 没有任何问题

    };       

2、截获OC对象后，向截获的对象变量赋值，则会产生编译错误：

    id array = [[NSMutableArray alloc] init];

    void (^blk)(void) = ^{

        array = [[NSMutableArray alloc] init]; // 产生编译错误

    };             

3、截获带有__block修饰符的OC对象，不管是使用该对象还是向该对象赋值，都没有任何问题：

       __block id array = [[NSMutableArray alloc] init];

           void (^blk)(void) = ^{

               array = [[NSMutableArray alloc] init]; // 没有任何问题

           };    

   4、由于Blocks支持截获C语言数组，所以在Block中需要用到数组时，要用指针代替数组操作：

       const char text[] = &quot;Hello&quot;;

       void (^blk)(void) = ^{

           printf(&quot;%c\n&quot;, text[2]); // 产生编译错误

       };

   改用指针来操作数组：

       const char *text = &quot;Hello&quot;;

       void (^blk)(void) = ^{

           printf(&quot;%c\n&quot;, text[2]); // 没有任何问题

       };
</code></pre><h2 id="3-Blocks的实现"><a href="#3-Blocks的实现" class="headerlink" title="3 Blocks的实现"></a>3 Blocks的实现</h2><h3 id="3-1-Block的本质"><a href="#3-1-Block的本质" class="headerlink" title="3.1 Block的本质"></a>3.1 Block的本质</h3><p>看似高大上的Block语法，实际上也是作为极普通的C语言源代码来处理的。通过clang（LLVM编译器）的“-rewrite-objc”选项，可以将含有Block语法的源代码转换为C++源代码（其实是使用了struct结构的C语言源代码）。    </p>
<pre><code>clang -rewrite-objc 源代码文件名
</code></pre><p>下例为一个最简单的Block的使用范例：</p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    void (^blk)(void) = ^{

        printf(&quot;Block&quot;);

    };

    blk();

    return 0;
}
</code></pre><p>将上述含有 Block 语法的源代码用<code>clang</code>转换为 C++ 源代码：</p>
<pre><code>struct __block_impl {

    void *isa;

    int Flags;

    int Reserved;

    void *FuncPtr;

};

struct __main_block_impl_0 {

    struct __block_impl impl;

    struct __main_block_desc_0* Desc;

    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {

    impl.isa = &amp;_NSConcreteStackBlock;

    impl.Flags = flags;

    impl.FuncPtr = fp;

    Desc = desc;

    }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

    printf(&quot;Block&quot;);

}

static struct __main_block_desc_0 {

    size_t reserved;

    size_t Block_size;

} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main()

{

    void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);

    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);

    return 0;

}
</code></pre><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><pre><code>void (^blk)(void) = ^{printf(&quot;Block&quot;);};
</code></pre><p>等价于：</p>
<pre><code>void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
</code></pre><p>分解为：</p>
<pre><code>void (*blk)(void) = (void (*)())&amp;tmp;

tmp = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
</code></pre><p>再分解：</p>
<pre><code>struct __main_block_impl_0 *blk = &amp;tmp;

struct __main_block_impl_0 tmp = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
</code></pre><h4 id="解读："><a href="#解读：" class="headerlink" title="解读："></a>解读：</h4><p>将由 Block literal 生成的 Block（value） 赋值给 Block 类型的变量<code>blk</code>；</p>
<p>即把栈上生成的<code>__main_block_impl_0</code>结构体的实例<code>tmp</code>的指针赋给变量<code>blk</code>；</p>
<p>我猜<code>^{printf(&quot;Block&quot;);}</code>就是所谓的<code>Block（value）</code>，该 Block 等价为<code>__main_block_impl_0</code>结构体类型的自动变量；换句话说，该 Block 就是<code>__main_block_impl_0</code>结构体在栈上生成的实例；</p>
<h4 id="综上分析得出结论："><a href="#综上分析得出结论：" class="headerlink" title="综上分析得出结论："></a>综上分析得出结论：</h4><p><code>void (^blk)(void) = ^{printf(&quot;Block&quot;);};</code>中的<code>^{printf(&quot;Block&quot;);}</code>为<code>__main_block_impl_0</code>结构体在栈上生成的实例；而<code>blk</code>为指向该实例的指针变量；</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Blosks/">Blosks</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2016_09_22_Blocks/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2016_09_22_Blocks/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Blog/" title="Blog">Blog<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/C/" title="C">C<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Git/" title="Git">Git<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C/" title="Objective-C">Objective-C<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>16</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/RAC/" title="RAC">RAC<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Octopress/" title="Octopress">Octopress<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GCD/" title="GCD">GCD<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Multithreading/" title="Multithreading">Multithreading<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NSOperation/" title="NSOperation">NSOperation<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Fragmentary/" title="Fragmentary">Fragmentary<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Delegate/" title="Delegate">Delegate<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Git/" title="Git">Git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/isEqual/" title="isEqual">isEqual<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NSString/" title="NSString">NSString<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UINavigationController/" title="UINavigationController">UINavigationController<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UIButton/" title="UIButton">UIButton<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Push/" title="Push">Push<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NSUserDefaults/" title="NSUserDefaults">NSUserDefaults<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Blosks/" title="Blosks">Blosks<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NSLog/" title="NSLog">NSLog<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Notifications/" title="Notifications">Notifications<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Animation/" title="Animation">Animation<sup>1</sup></a></li>
			
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Liu2er">Liu2er</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
