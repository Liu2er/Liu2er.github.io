
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Liu2er的技术博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Liu2er">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Liu2er的技术博客">
<meta property="og:url" content="http://liu2er.com/page/2/index.html">
<meta property="og:site_name" content="Liu2er的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liu2er的技术博客">

    
    <link rel="alternative" href="/atom.xml" title="Liu2er的技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Liu2er的技术博客">Liu2er的技术博客</a></h1>
				<h2 class="blog-motto">世界那么大，我早晚要去看</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:liu2er.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_GCD/" title="多线程编程之 GCD" itemprop="url">多线程编程之 GCD</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T12:27:35.000Z" itemprop="datePublished"> 发表于 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="GCD-中两个核心概念"><a href="#GCD-中两个核心概念" class="headerlink" title="GCD 中两个核心概念"></a>GCD 中两个核心概念</h2><ul>
<li><p><strong>队列：</strong>队列负责管理开发者提交的任务，队列始终以 FIFO（先进先出）的方式来处理任务，但由于任务的执行时间并不相同，因此处理的任务并不一定先结束。队列底层会维护一个线程池来处理用户提交的任务，线程池的作用就是<strong>执行</strong>队列管理的任务。</p>
</li>
<li><p><strong>任务：</strong>任务就是开发者提交给队列的<strong>工作单元</strong>，这些任务将会提交给队列底层维护的线程池执行。</p>
</li>
</ul>
<h2 id="GCD-中其它概念"><a href="#GCD-中其它概念" class="headerlink" title="GCD 中其它概念"></a>GCD 中其它概念</h2><p><strong>Dispatch Queue：</strong>执行处理的等待队列，按照追加的顺序（FIFO）执行处理。Dispatch Queue 分为 Serial Dispatch Queue 和 Concurrent Dispatch Queue；在不能改变执行的处理顺序或不想并发执行多个处理时使用 Serial Dispatch Queue。</p>
<p><strong>并行性（parallel）：</strong>同一时刻，有多条指令在多个处理器上同时执行；</p>
<p><strong>并发性（concurrency）：</strong>同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果；</p>
<p><strong>主线程：</strong>应用程序启动时，最先执行的线程，用来描绘用户界面、处理触摸屏幕的事件等。追加到主线程的处理在主线程的 RunLoop 中执行；</p>
<p>如果过多使用多线程，就会消耗大量内存，引起大量上下文切换，大幅度降低系统的响应性能；</p>
<h2 id="GCD-多线程编程的步骤"><a href="#GCD-多线程编程的步骤" class="headerlink" title="GCD 多线程编程的步骤"></a>GCD 多线程编程的步骤</h2><ul>
<li><p>创建队列；</p>
</li>
<li><p>创建任务，并将任务提交给队列；</p>
</li>
</ul>
<h2 id="Serial-Dispatch-Queue-和-Concurrent-Dispatch-Queue"><a href="#Serial-Dispatch-Queue-和-Concurrent-Dispatch-Queue" class="headerlink" title="Serial Dispatch Queue 和 Concurrent Dispatch Queue"></a>Serial Dispatch Queue 和 Concurrent Dispatch Queue</h2><p>当生成多个 Serial Dispatch Queue 时，各个 Serial Dispatch Queue 将并行执行。虽然在一个 Serial Dispatch Queue 中同时只能执行一个追加处理，但如果将10个处理分别追加到10个 Serial Dispatch Queue 中后，各个 Serial Dispatch Queue 执行一个追加处理，则能并发执行10个处理。</p>
<p>多个 Serial Dispatch Queue 同时执行会引发数据竞争问题。</p>
<p>当想并发执行又不发生数据竞争等问题的处理时，使用 Concurrent Dispatch Queue。</p>
<h2 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h2><pre><code>dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
</code></pre><p><strong>第一个参数const char *label：</strong>指定队列的名称，该名称推荐使用逆序全程域名（FQDN，fully qualified domain name）例如<code>com.example.gcd.MyConcurrentDispatchQueue</code>。该名称在 Xcode 和 Instruments 的调试器中作为 Dispatch Queue 名称表示。另外该名称也出现在应用程序崩溃时所生成的CrashLog中。</p>
<p><strong>第二个参数dispatch_queue_attr_t attr：</strong>指定队列的类型，即 Serial Dispatch Queue 或 Concurrent Dispatch Queue。当参数为NULL时为串行队列，当参数为DISPATCH_QUEUE_CONCURRENT时为并发队列。</p>
<pre><code>// 创建一个 Serial Dispatch Queue
dispatch_queue_t mySDQ = dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue&quot;, NULL);

// 创建一个 Concurrent Dispatch Queue
dispatch_queue_t myCDQ = dispatch_queue_create(&quot;com.example.gcd.MyConcurrentDispatchQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
</code></pre><p>ARC机制下不需要调用<code>void dispatch_release(dispatch_object_t object);</code>方法进行手动释放；    </p>
<h2 id="Main-Dispatch-Queue-和-Global-Dispatch-Queue"><a href="#Main-Dispatch-Queue-和-Global-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue 和 Global Dispatch Queue"></a>Main Dispatch Queue 和 Global Dispatch Queue</h2><p>Main Dispatch Queue 和 Global Dispatch Queue 是系统标准提供的 Dispatch Queue。</p>
<h3 id="Main-Dispatch-Queue"><a href="#Main-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue"></a>Main Dispatch Queue</h3><p><strong>Main Dispatch Queue：</strong>在主线程中执行的 Dispatch Queue，本质上是 Serial Dispatch Queue，追加到 Main Dispatch Queue 的处理在主线程的 RunLoop 中执行；</p>
<h5 id="dispatch-get-main-queue-方法"><a href="#dispatch-get-main-queue-方法" class="headerlink" title="dispatch_get_main_queue 方法"></a>dispatch_get_main_queue 方法</h5><pre><code>dispatch_queue_t dispatch_get_main_queue(void)
{
    return DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q);
}

其中

#define DISPATCH_GLOBAL_OBJECT(type, object) ((OS_OBJECT_BRIDGE type)&amp;(object))

#define OS_OBJECT_BRIDGE __bridge

struct dispatch_queue_s _dispatch_main_q;

也就是

dispatch_queue_t dispatch_get_main_queue(void)
{
    return (__bridge dispatch_queue_t) &amp; _dispatch_main_q;
}
</code></pre><p>举例：</p>
<pre><code>dispatch_queue_t mainDQ = dispatch_get_main_queue();
</code></pre><h3 id="Global-Dispatch-Queue"><a href="#Global-Dispatch-Queue" class="headerlink" title="Global Dispatch Queue"></a>Global Dispatch Queue</h3><p><strong>Global Dispatch Queue：</strong>是所有应用程序都能够使用的 Concurrent Dispatch Queue。没有必要通过 dispatch_queue_create 逐个生成 Concurrent Dispatch Queue，只要获取 Global Dispatch Queue 使用即可；</p>
<h5 id="dispatch-get-global-queue-方法"><a href="#dispatch-get-global-queue-方法" class="headerlink" title="dispatch_get_global_queue 方法"></a>dispatch_get_global_queue 方法</h5><pre><code>dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);
</code></pre><p>第二个参数 unsigned long flags：额外的旗标参数，暂未使用，只是为将来准备的，一般传入0即可；</p>
<h5 id="Global-Dispatch-Queue-有4个执行优先级"><a href="#Global-Dispatch-Queue-有4个执行优先级" class="headerlink" title="Global Dispatch Queue 有4个执行优先级"></a>Global Dispatch Queue 有4个执行优先级</h5><pre><code>DISPATCH_QUEUE_PRIORITY_HIGH 2
DISPATCH_QUEUE_PRIORITY_DEFAULT 0
DISPATCH_QUEUE_PRIORITY_LOW (-2)
DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN
</code></pre><p>举例：</p>
<pre><code>dispatch_queue_t globalDQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</code></pre><h2 id="dispatch-asyc-和-dispatch-syc"><a href="#dispatch-asyc-和-dispatch-syc" class="headerlink" title="dispatch_asyc 和 dispatch_syc"></a>dispatch_asyc 和 dispatch_syc</h2><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p>将处理在指定时间追加到 Dispatch Queue。经常和dispatch_time一起使用：</p>
<h4 id="dispatch-time"><a href="#dispatch-time" class="headerlink" title="dispatch_time"></a>dispatch_time</h4><pre><code>dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);
</code></pre><p>第一个参数 dispatch_time_t when：用来指定开始时间，经常用的参数是<code>DISPATCH_TIME_NOW</code>和<code>DISPATCH_TIME_FOREVER</code>；</p>
<pre><code>typedef uint64_t dispatch_time_t;

#define DISPATCH_TIME_NOW (0ull)
#define DISPATCH_TIME_FOREVER (~0ull)
</code></pre><p>第二个参数 int64_t delta：用来指定偏移时长，单位为纳秒，比如<code>3ull * NSEC_PER_SEC</code>表示<code>3 * 1000000000纳秒 = 3秒</code>；</p>
<pre><code>typedef    long long  int64_t;

#define NSEC_PER_SEC  1000000000ull  // 10的9次方，纳秒是10的-9次方
#define NSEC_PER_MSEC 1000000ull
#define USEC_PER_SEC  1000000ull
#define NSEC_PER_USEC 1000ull
</code></pre><p>其中数字后面的后缀ull表示unsigned long long；</p>
<h4 id="dispatch-after-1"><a href="#dispatch-after-1" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><pre><code>void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);
</code></pre><p>举例，在 3 秒后把某个指定的 Block 追加到 Main Dispatch Queue 中：</p>
<pre><code>dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);

dispatch_after(time, dispatch_get_main_queue(), ^{
    NSLog(@&quot;3秒后把本操作追加到 Main Dispatch Queue 中执行&quot;);
});
</code></pre><p>也可以将 dispatch_time 和 dispatch_after 两个方法合并起来用，这也是比较常用的方式：</p>
<pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3ull * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    NSLog(@&quot;3秒后把本操作追加到 Main Dispatch Queue 中执行&quot;);
});  
</code></pre><h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h2><p>用来变更 Dispatch Queue 的执行优先级（或执行层次）。</p>
<pre><code>void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);
</code></pre><p>第一个参数 dispatch_object_t object：被改变对象；</p>
<p>第二个参数 dispatch_queue_t queue：（目标）参考优先级。</p>
<p>将 dispatch_object_t object 的优先级改为与 dispatch_queue_t queue 的优先级相同；</p>
<p>举例：</p>
<pre><code>dispatch_queue_t mySDQ = dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue&quot;, NULL);

dispatch_queue_t myGDQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);

dispatch_set_target_queue(mySDQ, myGDQ);
</code></pre><p><strong>使用场景举例：</strong></p>
<p>有几个不可并发执行的处理，但是因为某种原因必须追加到多个 Serial Dispatch Queue 中时，会产生不可预期的后果，但是如果用dispatch_set_target_queue函数将目标指定为某一个 Serial Dispatch Queue，即可防止处理并发执行。但目前为止尚未遇到过这种情况。</p>
<h2 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h2><h2 id="dispatch-barrier-asyc"><a href="#dispatch-barrier-asyc" class="headerlink" title="dispatch_barrier_asyc"></a>dispatch_barrier_asyc</h2><h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><h2 id="dispatch-suspend-和-dispatch-resume"><a href="#dispatch-suspend-和-dispatch-resume" class="headerlink" title="dispatch_suspend 和 dispatch_resume"></a>dispatch_suspend 和 dispatch_resume</h2><h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h2><p>dispatch_once 函数的作用是在整个应用程序的生命周期中只执行一次代码块，而且是线程同步的，即不需要再使用@synchronized 之类的语句。</p>
<h2 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h2><h2 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h2>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/GCD/">GCD</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/17/2015_08_17_GCD/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/17/2015_08_17_GCD/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/2015_08_17_CFragmentary/" title="C 语言：零碎知识总结" itemprop="url">C 语言：零碎知识总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T02:48:28.000Z" itemprop="datePublished"> 发表于 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数。</p>
<pre><code>// 定义回调函数1
void PrintfText()
{
    printf(&quot;Hello World!\n&quot;);
}

// 定义回调函数2
void PrintfInt()
{
    printf(&quot;10\n&quot;);
}

// 定义实现回调函数的&quot;调用函数&quot;
void CallPrintf(void (*callfuct)(void))
{
    callfuct();
}

// 在main函数中实现函数回调
int main(int argc,char* argv[])
{
    CallPrintf(PrintfText);
    CallPrintf(PrintfInt);
    return 0;
}
</code></pre>
        
        
        <p class="article-more-link">
          
            <a href="/2015/08/17/2015_08_17_CFragmentary/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/17/2015_08_17_CFragmentary/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/17/2015_08_17_CFragmentary/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2015_08_16_NSStringIsEqual/" title="isEqual 和 == 的比较" itemprop="url">isEqual 和 == 的比较</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T11:45:53.000Z" itemprop="datePublished"> 发表于 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>== 和 isEqual 都是用来判断连个变量是否相等；</p>
<h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>1.<code>数值型</code>的基本类型变量比较：不一定要求数据类型严格相同，只要值相等，则返回真；</p>
<p>例如：<code>int型50 == float型50.0f；</code></p>
<p>2.<code>指针类型</code>变量比较：必须指向同一个对象，即两个指针变量保存的内存地址相同，返回真；</p>
<p>3.没有继承关系的两个指针变量比较：编译时提示警告；</p>
<h2 id="isEqual"><a href="#isEqual" class="headerlink" title="isEqual"></a>isEqual</h2><p>1.<code>指针类型</code>变量比较：同 ==，都是必须指向同一个对象，即两个指针变量保存的内存地址相同，返回真；</p>
<p>2.NSString 的 isEqual 方法：只要两个字符串包含相同的字符串序列，则返回真；</p>
<p>因为 isEqual 方法就指针类型变量的比较，本身与 == 没有区别，同时没有太大的意义，所以 NSString 重写了该方法，实现了值比较而不是地址比较。我们在编程时同样可以重写该方法来满足我们所要求的比较方式；</p>
<h2 id="字符型常量"><a href="#字符型常量" class="headerlink" title="字符型常量"></a>字符型常量</h2><p>像类似于<code>@&quot;hello&quot;</code>这种字符型常量是由常量池来存储管理的，常量池可以保证相同的字符串直接量只有一个；</p>
<p>而<code>[NSString stringWithFormat:@&quot;hello&quot;]</code>类型的字符串对象是运行时创建出来的，它被保存在运行时内存区（即堆内存），不会放入常量池中；</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/isEqual/">isEqual</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2015_08_16_NSStringIsEqual/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2015_08_16_NSStringIsEqual/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2015_08_16_NSString/" title="NSString 转换" itemprop="url">NSString 转换</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T11:12:14.000Z" itemprop="datePublished"> 发表于 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="其它-——-gt-NSString"><a href="#其它-——-gt-NSString" class="headerlink" title="其它 ——&gt; NSString"></a>其它 ——&gt; NSString</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSStringFromRange</span>( <span class="built_in">NSRange</span> range );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromRect</span>( <span class="built_in">NSRect</span> aRect );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromSelector</span>( SEL aSelector );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromClass</span>( __<span class="keyword">unsafe_unretained</span> Class aClass );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromProtocol</span>( Protocol *proto );</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSStringFromHashTable</span>( <span class="built_in">NSHashTable</span> *table );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromMapTable</span>( <span class="built_in">NSMapTable</span> *table );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromPoint</span>( <span class="built_in">NSPoint</span> aPoint );</div><div class="line"></div><div class="line"><span class="built_in">NSStringFromSize</span>( <span class="built_in">NSSize</span> aSize );</div></pre></td></tr></table></figure>
<p>举例：</p>
<pre><code>NSString *string = NSStringFromClass([NSArray class]);

NSLog(@&quot;NSArray 的类名是：%@&quot;,string);

输出如下：

2015-08-18 16:10:17.908 NewCommandTest[845:137450] NSArray 的类名是：NSArray
</code></pre><h2 id="NSNumber-——-gt-NSString"><a href="#NSNumber-——-gt-NSString" class="headerlink" title="NSNumber ——&gt; NSString"></a>NSNumber ——&gt; NSString</h2><pre><code>NSNumber *number = [NSNumber numberWithInt:20];

// 转换方法1
NSString *string = [number description];

// 转换方法2
NSString *string = [NSString stringWithFormat:@&quot;%d&quot;, [number intValue]];
</code></pre><p>本例是将<code>@20</code>转换为<code>@&quot;20&quot;</code>。</p>
<h2 id="NSData-——-gt-NSString"><a href="#NSData-——-gt-NSString" class="headerlink" title="NSData ——&gt; NSString"></a>NSData ——&gt; NSString</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.baidu.com"</span>]];</div><div class="line">       </div><div class="line"><span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
            <a href="/2015/08/16/2015_08_16_NSString/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C/">Objective-C</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/NSString/">NSString</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2015_08_16_NSString/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2015_08_16_NSString/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2016_09_22_Blocks/" title="Blosks 浅析" itemprop="url">Blosks 浅析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T07:28:30.000Z" itemprop="datePublished"> 发表于 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-Blocks概要"><a href="#1-Blocks概要" class="headerlink" title="1 Blocks概要"></a>1 Blocks概要</h2><p>带有自动变量（局部变量）的匿名函数（在标准的C和Objective-C语言中是不允许有匿名函数的）。</p>
<p>C语言中的变量类型：</p>
<p>1.自动变量Automatic variables（局部变量local variables）</p>
<p>2.静态变量Static variables（静态局部变量static local variables）</p>
<p>3.全局变量Global variables</p>
<p>4.静态全局变量Static global variables</p>
<p>5.函数的参数Function arguments</p>
<p>其中，在函数的多次调用之间能够传递值的变量有：</p>
<p>1.静态变量（静态局部变量）</p>
<p>2.静态全局变量</p>
<p>3.全局变量</p>
<h2 id="2-Blocks模式"><a href="#2-Blocks模式" class="headerlink" title="2 Blocks模式"></a>2 Blocks模式</h2><h3 id="2-1-Blocks语法"><a href="#2-1-Blocks语法" class="headerlink" title="2.1 Blocks语法"></a>2.1 Blocks语法</h3><p>完整形式的Block语法与C语言函数相比，仅有两点区别：</p>
<p>（1）没有函数名。</p>
<p>（2）带有插入记号“^”。</p>
<h4 id="完整形式的Block语法格式："><a href="#完整形式的Block语法格式：" class="headerlink" title="完整形式的Block语法格式："></a>完整形式的Block语法格式：</h4><pre><code>^ 返回值类型 参数列表 表达式
</code></pre><p>例如：    </p>
<pre><code>^int (int count) {return count + 1;}
</code></pre><h4 id="省略返回值类型的Block语法格式："><a href="#省略返回值类型的Block语法格式：" class="headerlink" title="省略返回值类型的Block语法格式："></a>省略返回值类型的Block语法格式：</h4><pre><code>^ 参数列表 表达式
</code></pre><h4 id="省略返回值类型时则Block的返回值类型为："><a href="#省略返回值类型时则Block的返回值类型为：" class="headerlink" title="省略返回值类型时则Block的返回值类型为："></a>省略返回值类型时则Block的返回值类型为：</h4><p>1.如果表达式没有return语句，则Block的返回值类型为void；</p>
<p>2.如果表达式有return语句，则Block的返回值类型就是return的类型；</p>
<p>3.如果表达式有多个return语句，则所有return的类型必须相同；</p>
<p>例如：</p>
<pre><code>^(int count) {return count + 1;}
</code></pre><h4 id="省略返回值类型和参数列表的Block语法格式："><a href="#省略返回值类型和参数列表的Block语法格式：" class="headerlink" title="省略返回值类型和参数列表的Block语法格式："></a>省略返回值类型和参数列表的Block语法格式：</h4><pre><code>^ 表达式
</code></pre><p>当不使用参数时，参数列表可以省略。</p>
<p>例如：</p>
<pre><code>^{printf(&quot;Blocks&quot;);}
</code></pre><h3 id="2-2-Block类型变量"><a href="#2-2-Block类型变量" class="headerlink" title="2.2 Block类型变量"></a>2.2 Block类型变量</h3><p>函数指针类型变量举例：    </p>
<pre><code>int func(int count)
{
    return count + 1;
}

int (*funcptr)(int) = &amp;func;

funcptr(5);
</code></pre><p>类似地，可将Block literal赋值给Block-type变量。When a Block literal is in source code, a value is generated. The value can be assigned to a variable of the Block type. In Blocks, the generated value is called Block as well. “Block”既指Block literal itself in a source code，也指the value generated from the Block literal.</p>
<p>Block类型变量举例：</p>
<pre><code>int (^blk)(int) = ^int (int count){return count + 1;};

blk(5);
</code></pre><p>注意，Block代码块不能像函数一样在外面定义，只能像一个表达式一样使用，比如定义完了立即赋给一个Block类型变量，或者作为函数的返回值。这里的Block就是生成的value。</p>
<p>Block类型变量与一般的C语言变量完全相同，都可以用作自动变量、静态变量、全局变量、静态全局变量、函数参数：</p>
<pre><code>1、将Block赋值给Block类型变量：

int (^blk)(int) = ^int (int count){return count + 1;};   

2、将Block类型变量赋值给Block类型变量：

int (^blk1)(int) = blk;

int (^blk2)(int);

blk2 = blk;

3、将Block类型变量作为函数参数来向函数传递Block：

void func(int (^blk)(int))

{
    // 执行代码...
}

4、将Block作为函数的返回值返回：

int (^func())(int)

{
    // 执行代码...
    return ^int (int count){return count + 1;};
}

5、也可以定义Block的指针类型变量：

typedef int (^blk_t)(int);

blk_t blk = ^int (int count){return count + 1;};

blk_t *blkptr = &amp;blk;

(*blkptr)(10);
</code></pre><h3 id="2-3-截获自动变量值和-block说明符"><a href="#2-3-截获自动变量值和-block说明符" class="headerlink" title="2.3 截获自动变量值和__block说明符"></a>2.3 截获自动变量值和__block说明符</h3><p>基本类型变量的截获：</p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    int val = 10; 

    void (^blk)(void) = ^{printf(&quot;%d\n&quot;, val);};   // 在这里截获自动变量val的值 

    blk();  // 输出10，注意不要写成blk;

    val = 2;

    blk();  // 输出也是10
}
</code></pre><p>Block语法使用了自动变量val的值，即Block语法保存了该自动变量的瞬间值，在执行完Block语法后，即使改写了Block中使用的自动变量的值也不会影响Block执行时的自动变量的值，称之为“截获自动变量的值”。</p>
<p>When automatic variables are captured, the values are read-only in the Block. 在上例的Block语法里尝试将val的值改为1时，会产生变异错误。</p>
<p>在自动变量前面加上__block说明符后，就可在Block里和Block外修改该自动变量的值而影响到Block。    </p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    __block int val = 10;

    void (^blk)(void) = ^{printf(&quot;%d\n&quot;, val);};   // 在这里截获自动变量val的值 

    blk();  // 输出10

    val = 2;

    blk();  // 输出2
}
</code></pre><p>以及：    </p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    __block int val = 10;

    void (^blk)(void) = ^{

        val = 1;

        printf(&quot;%d\n&quot;, val);

    };

    blk();  // 输出1

}
</code></pre><h4 id="对象类型变量的截获："><a href="#对象类型变量的截获：" class="headerlink" title="对象类型变量的截获："></a>对象类型变量的截获：</h4><pre><code>1、截获OC对象后，调用该对象的方法来修改该对象（使用截获的值），没有任何问题：

    id array = [[NSMutableArray alloc] init];

    void (^blk)(void) = ^{

        id obj = [[NSObject alloc] init];

            [array addObject:obj];  // 没有任何问题

    };       

2、截获OC对象后，向截获的对象变量赋值，则会产生编译错误：

    id array = [[NSMutableArray alloc] init];

    void (^blk)(void) = ^{

        array = [[NSMutableArray alloc] init]; // 产生编译错误

    };             

3、截获带有__block修饰符的OC对象，不管是使用该对象还是向该对象赋值，都没有任何问题：

       __block id array = [[NSMutableArray alloc] init];

           void (^blk)(void) = ^{

               array = [[NSMutableArray alloc] init]; // 没有任何问题

           };    

   4、由于Blocks支持截获C语言数组，所以在Block中需要用到数组时，要用指针代替数组操作：

       const char text[] = &quot;Hello&quot;;

       void (^blk)(void) = ^{

           printf(&quot;%c\n&quot;, text[2]); // 产生编译错误

       };

   改用指针来操作数组：

       const char *text = &quot;Hello&quot;;

       void (^blk)(void) = ^{

           printf(&quot;%c\n&quot;, text[2]); // 没有任何问题

       };
</code></pre><h2 id="3-Blocks的实现"><a href="#3-Blocks的实现" class="headerlink" title="3 Blocks的实现"></a>3 Blocks的实现</h2><h3 id="3-1-Block的本质"><a href="#3-1-Block的本质" class="headerlink" title="3.1 Block的本质"></a>3.1 Block的本质</h3><p>看似高大上的Block语法，实际上也是作为极普通的C语言源代码来处理的。通过clang（LLVM编译器）的“-rewrite-objc”选项，可以将含有Block语法的源代码转换为C++源代码（其实是使用了struct结构的C语言源代码）。    </p>
<pre><code>clang -rewrite-objc 源代码文件名
</code></pre><p>下例为一个最简单的Block的使用范例：</p>
<pre><code>#include &lt;stdio.h&gt;

int main()

{
    void (^blk)(void) = ^{

        printf(&quot;Block&quot;);

    };

    blk();

    return 0;
}
</code></pre><p>将上述含有 Block 语法的源代码用<code>clang</code>转换为 C++ 源代码：</p>
<pre><code>struct __block_impl {

    void *isa;

    int Flags;

    int Reserved;

    void *FuncPtr;

};

struct __main_block_impl_0 {

    struct __block_impl impl;

    struct __main_block_desc_0* Desc;

    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {

    impl.isa = &amp;_NSConcreteStackBlock;

    impl.Flags = flags;

    impl.FuncPtr = fp;

    Desc = desc;

    }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

    printf(&quot;Block&quot;);

}

static struct __main_block_desc_0 {

    size_t reserved;

    size_t Block_size;

} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main()

{

    void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);

    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);

    return 0;

}
</code></pre><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><pre><code>void (^blk)(void) = ^{printf(&quot;Block&quot;);};
</code></pre><p>等价于：</p>
<pre><code>void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
</code></pre><p>分解为：</p>
<pre><code>void (*blk)(void) = (void (*)())&amp;tmp;

tmp = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
</code></pre><p>再分解：</p>
<pre><code>struct __main_block_impl_0 *blk = &amp;tmp;

struct __main_block_impl_0 tmp = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
</code></pre><h4 id="解读："><a href="#解读：" class="headerlink" title="解读："></a>解读：</h4><p>将由 Block literal 生成的 Block（value） 赋值给 Block 类型的变量<code>blk</code>；</p>
<p>即把栈上生成的<code>__main_block_impl_0</code>结构体的实例<code>tmp</code>的指针赋给变量<code>blk</code>；</p>
<p>我猜<code>^{printf(&quot;Block&quot;);}</code>就是所谓的<code>Block（value）</code>，该 Block 等价为<code>__main_block_impl_0</code>结构体类型的自动变量；换句话说，该 Block 就是<code>__main_block_impl_0</code>结构体在栈上生成的实例；</p>
<h4 id="综上分析得出结论："><a href="#综上分析得出结论：" class="headerlink" title="综上分析得出结论："></a>综上分析得出结论：</h4><p><code>void (^blk)(void) = ^{printf(&quot;Block&quot;);};</code>中的<code>^{printf(&quot;Block&quot;);}</code>为<code>__main_block_impl_0</code>结构体在栈上生成的实例；而<code>blk</code>为指向该实例的指针变量；</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Blosks/">Blosks</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2016_09_22_Blocks/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2016_09_22_Blocks/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/2015_08_16_Octopress/" title="用 Octopress 搭建静态博客并发布文章" itemprop="url">用 Octopress 搭建静态博客并发布文章</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Liu2er" target="_blank" itemprop="author">Liu2er</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T05:51:41.000Z" itemprop="datePublished"> 发表于 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="克隆Octopress"><a href="#克隆Octopress" class="headerlink" title="克隆Octopress"></a>克隆Octopress</h3><p>从Github上将Octopress项目克隆到本地的Octopress目录下：</p>
<pre><code>git clone git://github.com/imathis/octopress.git Octopress
</code></pre><h3 id="进入Octopress项目根目录"><a href="#进入Octopress项目根目录" class="headerlink" title="进入Octopress项目根目录"></a>进入Octopress项目根目录</h3><pre><code>cd Octopress
</code></pre>
        
        
        <p class="article-more-link">
          
            <a href="/2015/08/16/2015_08_16_Octopress/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Blog/">Blog</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Octopress/">Octopress</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/2015_08_16_Octopress/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/2015_08_16_Octopress/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Blog/" title="Blog">Blog<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/C/" title="C">C<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Git/" title="Git">Git<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C/" title="Objective-C">Objective-C<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>11</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/RAC/" title="RAC">RAC<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/NSString/" title="NSString">NSString<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GCD/" title="GCD">GCD<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Octopress/" title="Octopress">Octopress<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Git/" title="Git">Git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Delegate/" title="Delegate">Delegate<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/isEqual/" title="isEqual">isEqual<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Fragmentary/" title="Fragmentary">Fragmentary<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UINavigationController/" title="UINavigationController">UINavigationController<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Push/" title="Push">Push<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UIButton/" title="UIButton">UIButton<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/NSUserDefaults/" title="NSUserDefaults">NSUserDefaults<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Blosks/" title="Blosks">Blosks<sup>1</sup></a></li>
			
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Liu2er">Liu2er</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
